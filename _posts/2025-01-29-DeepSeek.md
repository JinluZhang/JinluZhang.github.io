---
title: 'DeepSeek学习笔记'
date: 2025-01-29
categories: 技术
author: Beaug
tags: 大模型 DeepSeekMoE
---

春节假期想干点儿轻松的，翻译+记笔记使我快乐。
（公式多渲染慢）


# 一些HighLight

 - deepseek一系列工作的创新点概括为：1）DeepSeekMoE；2）MLA（于V2提出）；3）FP8精度训练（于V3大规模验证）；4）MTP（于V3提出）；5）用R1数据作为强化学习的reasoning data，蒸馏了R1的推理能力（V3和R1均有论述）；6）抛弃SFT只用纯RL做post-train（R1提出）；7）GRPO（于Math提出）。前四个创新点都是为了省钱，提高了训练和inference的经济性，共同促成了deepseek如此惊艳的训练和inference效率，火出了圈。后三个惊艳在其开放性上，是第一个达到了与o1相当的reasoning能力并完全开放技术细节的模型。

 - 【MLA】参考llama中的Attention模块详细拆解图。 https://jinluzhang.github.io/%E6%8A%80%E6%9C%AF/2023/08/02/LLAMA2-code.html 。比如我们在第T步的输入是500个token，输出了第501个token，那么继续自回归inference，在第T+1步要输入501个token，此时应该要计算这个501个token的WQ、WK、WV矩阵乘法、501个query和501个key之间的score，但前面的500个token的已经算过了，为了减少计算量，会把他们缓存下来。但这个key和value的缓存比较大，是2 * dim * token_length大小的，本文的MLA可以减少这部分的缓存空间。低秩是降低参数量的常用手段，LoRA里也有。

 - 【MLA】原本第一反应这是时间换空间，在MHA里，$W^K \mathbf{h}_t$ 和 $W^V \mathbf{h}_t$ 是不用计算的，结果已经被缓存了。但是MLA需要多算两次up-projection： $W^{UK} \mathbf{c}_t^{KV}$ 、 $W^{UV} \mathbf{c}_t^{KV}$  。 但巧妙在参数矩阵可以合并，并且合并后，对应的 $W^Q$ 和 $W^O$ size也降低了，和MHA相比inference时候的计算量也降低了。

- 【训练精度】应该是第一个全程用FP8精度训练、KV存储还进一步压缩到6位，但训出来效果这么好的模型了。训练是木桶，token数量、token质量、模型参数量、深度层数、广度dim长度、精度，都是一块块木板，大家一样长才最经济，但之前可能没人有勇气说精度这块板子降到FP16都还长，能直接降到8。无论deepseek的训练多经济，做训练精度的对比实验都需要不小的开销，验证这个insight还挺需要勇气的。

- 【负载均衡】V2把负载均衡从工程领域引入进算法，引入额外loss来控制选择的平衡性，然后在V3又还回去了。load balanc本身和内容无关，在工程领域解题确实是更合适的。

- 【MTP】首先还是效率考量，一次预测多个token比预测一个的样本利用率更高，在推理的时候也可以有多倍的效率提升（虽然DeepSeek在推理时没这么做，MTP只用在了训练中，且是辅助loss）。此外，GPT的续写作文比BERT的完形填空难，MTP的一次往下写4个字比GPT的一次写1个难，更难的训练目标确实有可能推高模型的能力天花板。

- 【工程实现】因为DeepSeek的算法架构设计，导致computation-to-communication ratio差不多在1：1，根据这个题面设计了解题方案DualPipe，在一个前向+反向chunks里，把计算与通信overlap起来。这好像是我第一次在算法论文里看到介绍这么详细的工程框架，解题方案特别合理。



---

# DeepSeekMoE

## Abstract

在大规模语言模型的时代，混合专家（MoE）是一种有前景的架构，能够在扩展模型参数时管理计算成本。然而，传统的MoE架构，如GShard，它通过激活从 N 个专家中选取的 top-K 个专家，面临着确保专家专长的挑战（即每个专家获取不重叠且集中的知识）。为此，我们提出了DeepSeekMoE架构，旨在实现终极专家专长 ultimate expert specialization。它包含两个主要策略：（1）将专家细分为更细粒度的 $mN$ 个，并激活其中的 $mK$ 个，使得有更灵活的激专家组合；（2）隔离出 $K_s$ 个专家为共享专家，旨在捕捉共同的知识并减少路由专家之间的冗余。

我们从2B参数的规模开始，展示了DeepSeekMoE 2B在性能上与GShard 2.9B相当，后者有1.5倍的专家参数和计算量。此外，DeepSeekMoE 2B几乎达到了与其密集版本相同参数数量的性能，后者设定了MoE模型的上限。随后，我们将DeepSeekMoE扩展到16B参数，展示其在计算量仅约为40%的情况下，达到了与LLaMA2 7B相当的性能。进一步地，我们初步将DeepSeekMoE扩展到145B参数，验证了它相较于GShard架构的显著优势，并显示出与DeepSeek 67B相当的性能，仅使用了28.5%（甚至可能是18.2%）的计算量。

## 1. Introduction

近年来的研究和实践已实验证明，若有足够的训练数据，通过增加参数和计算预算扩展语言模型，可以获得显著更强的模型（Brown et al., 2020; Hoffmann et al., 2022; OpenAI, 2023; Touvron et al., 2023a）。然而，需要注意的是，扩展模型至极大规模也伴随着极高的计算成本。考虑到这一巨大的成本，混合专家（MoE）架构（Jacobs et al., 1991; Jordan 和 Jacobs, 1994; Shazeer et al., 2017）成为了一种受欢迎的解决方案。它能够支持参数扩展，同时保持计算成本在合理水平。MoE架构在Transformers中的应用（Vaswani et al., 2017）已成功地尝试了将语言模型扩展到相当大的规模（Du et al., 2022; Fedus et al., 2021; Lepikhin et al., 2021; Zoph, 2022），并取得了显著的性能。这些成果凸显了MoE语言模型的巨大潜力和前景。

尽管MoE架构具有巨大的潜力，现有的MoE架构可能存在知识混杂hybridity和知识冗余redundancy的问题，这限制了专家的专业性，即每个专家获取不重叠且集中的知识（non-overlapping and focused knowledge）。传统的MoE架构通过将Transformer中的前馈网络（FFN）替换为MoE层来实现，每个MoE层由多个专家组成，每个专家的结构与标准FFN相同，每个token会被分配给一个（Fedus et al., 2021）或两个（Lepikhin et al., 2021）专家。该架构存在两个潜在问题：（1）Knowledge Hybridity 知识混杂：现有的MoE实践通常采用有限数量的专家（例如8个或16个），专家数量少，因此分配给某一专家的tokens往往覆盖了多种知识。该专家的参数往往会组合多种不同类型的知识，这些知识难以同时利用。（2）Knowledge Redundancy 知识冗余：分配给不同专家的token可能有一些一样的common知识。多个专家可能在各自的参数中获取相同的知识，从而导致专家参数的冗余。这些问题共同阻碍了现有MoE实践中的专家专长性，防止它们达到MoE模型的理论上限性能。

针对上述问题，我们提出了DeepSeekMoE，一种旨在实现最终专家专长的创新MoE架构。我们的架构包含两个主要策略：（1）Fine-Grained Expert Segmentation：在保持参数数量不变的情况下，我们通过进一步细分FFN的隐藏维度，将专家分割为更细的粒度。相应地，在保持计算成本不变的情况下，我们还激活更多细粒度的专家，从而实现更灵活的激活专家组合。细粒度的专家细分允许将多样化的知识更加精细地分解并精确地学习到不同专家中，使得每个专家保持更高的专长性。此外，激活专家的组合灵活性增加也有助于更准确、针对性的知识获取。（2）Shared Expert Isolation 隔离共享专家：我们将部分专家隔离为共享专家，这些专家始终保持激活，旨在捕捉并整合跨越不同上下文的共同知识。通过将共享知识压缩到这些共享专家中，可以减少其他路由专家之间的冗余。这可以提高参数效率，并确保每个路由专家通过专注于独特的方面保持专业化。这些架构创新为训练一个参数高效的MoE语言模型提供了机会，在该模型中，每个专家都具有高度的专长性。

从2B参数的规模开始，我们验证了DeepSeekMoE架构的优势。我们在12个zero-shot或few-shot基准上进行了评估，涵盖了多种任务。实验证据表明，DeepSeekMoE 2B远超GShard 2B（Lepikhin et al., 2021），甚至与GShard 2.9B相匹配，后者的专家参数和计算量是前者的1.5倍。值得注意的是，我们发现DeepSeekMoE 2B几乎接近其密集模型版本的性能，后者具有相同数量的参数，设定了MoE语言模型的严格上限。为了获得更深入的见解，我们对DeepSeekMoE的专家专长性进行了详细的消融研究和分析。这些研究验证了细粒度专家细分和共享专家隔离的有效性，并提供了实证证据，支持DeepSeekMoE能够实现高度专家专长的观点。

通过利用我们的架构，我们随后将模型参数扩展到16B，并在一个包含2T tokens的大规模语料库上训练了DeepSeekMoE 16B。评估结果表明，在计算量仅为40%的情况下，DeepSeekMoE 16B达到了与DeepSeek 7B（DeepSeek-AI, 2024）相当的性能，后者是一个在同样2T语料库上训练的密集模型。我们还将DeepSeekMoE与开源模型进行了比较，评估结果显示，DeepSeekMoE 16B始终大幅超越了具有类似激活参数数量的模型，并且与LLaMA2 7B（Touvron et al., 2023b）相当，后者的激活参数大约是前者的2.5倍。图1展示了在Open LLM Leaderboard上的评估结果。此外，我们进行监督微调（SFT）以进行对齐，将模型转换为聊天模型。评估结果表明，DeepSeekMoE Chat 16B在聊天场景中的表现与DeepSeek Chat 7B和LLaMA2 SFT 7B相当。受到这些结果的鼓舞，我们进一步进行了初步的工作，将DeepSeekMoE扩展到145B。实验结果仍然一致地验证了它相较于GShard架构的显著优势。此外，使用仅28.5%（甚至可能是18.2%）的计算量，它展现出了与DeepSeek 67B相当的性能。

我们的贡献总结如下：

- **Architectural Innovation**：我们提出了DeepSeekMoE，这是一种创新的MoE架构，旨在实现最终的专家专长性，采用了细粒度专家细分和共享专家隔离两大策略。
  
- **Empirical Validation**：我们进行了广泛的实验，实证验证了DeepSeekMoE架构的有效性。实验结果验证了DeepSeekMoE 2B中专家专长性的高水平，并表明DeepSeekMoE 2B几乎可以接近MoE模型的上限性能。

- **Scalability**：我们将DeepSeekMoE扩展至16B模型，并展示了在计算量仅约40%的情况下，DeepSeekMoE 16B与DeepSeek 7B和LLaMA2 7B达到了可比的性能。我们还进行了初步尝试，将DeepSeekMoE扩展到145B，突显了其在GShard架构上的一致性优势，并展示了与DeepSeek 67B相当的性能。

- **Alignment for MoE**：我们成功地对DeepSeekMoE 16B进行了监督微调，创建了一个对齐的聊天模型，展示了DeepSeekMoE 16B的适应性和多样性。

- **Public Release**：本着开放研究的精神，我们将DeepSeekMoE 16B的模型检查点公开发布。值得注意的是，该模型可以在单个具有40GB内存的GPU上部署，无需量化处理。


## 2. 基础知识：Transformer中的混合专家（MoE）

我们首先介绍在Transformer语言模型中常用的通用MoE架构。标准的Transformer语言模型通过堆叠𝐿层标准的Transformer blocks来构建，其中每个块可以表示如下：

$$
u^l_{1:T} = \text{Self-Att}\left(h^{l-1}_{1:T}\right) + h^{l-1}_{1:T}, \tag{1}
$$

$$
h_{t}^{l} = \text{FFN}\left(u_{t}^{l}\right) + u_{t}^{l}, \tag{2}
$$

其中，𝑇表示序列长度，Self-Att(·)表示自注意力模块，FFN(·)表示前馈网络（Feed-Forward Network，FFN）， $ u^l_{1:T} \in \mathbb{R}^{T \times d}$ 是所有token经过第𝑙层自注意力模块后的隐藏状态， $h_{t}^{l} \in \mathbb{R}^{d}$ 是第𝑡个token经过第𝑙层整个Transformer block后的输出隐藏状态。为简便起见，以上公式中省略了层归一化。

构建MoE语言模型的典型做法通常是在Transformer的指定间隔处将FFN替换为MoE层（Du等，2022；Fedus等，2021；Lepikhin等，2021；Zoph，2022）。MoE层由多个专家组成，每个专家在结构上与标准FFN相同。然后，每个令牌将被分配给一个（Fedus等，2021）或两个（Lepikhin等，2021）专家。如果第𝑙层的FFN被MoE层替换，那么其输出隐藏状态 $h_{t}^{l}$ 的计算可以表示为：

$$
h_t^l = \sum_{i=1}^{N} \left( g_{i,t} \cdot \text{FFN}_i(u_t^l) \right) + u_t^l \tag{3}
$$

$$
g_{i,t} = 
\begin{cases} 
s_{i,t}, & s_{i,t} \in \text{Topk}(\{s_{j,t} | 1 \leq j \leq N \}, K) \\
0, & \text{otherwise}
\end{cases}  \tag{4}
$$

$$
s_{i,t} = \text{Softmax}_i(u_t^l e_i^l)  \tag{5}
$$

其中，𝑁表示专家的总数，FFN𝑖(·)是第𝑖个专家的FFN， $g_{i,t}$ 表示第𝑖个专家的门控值， $s_{i,t}$ 表示令牌与专家之间的亲和度，Topk(·,𝐾)表示对于第𝑡个令牌和所有𝑁个专家计算出的亲和度中的前𝐾个最高值的集合。$e_i^l$ 是第l层第i个专家的Centroid质心。注意  $g_{i,t}$ 是稀疏的，只有𝐾 out of 𝑁个值是非0的，这保证了计算的高效性。为简便起见，以上公式中省略了层归一化。

<span style="color:red">【TODO】看看具体的工程实现，模型checkout文件中的参数矩阵是dense的，是在训练和推理过程中通过乘0的方式让一部分参数不激活不计算，看看是怎么让具体的乘法计算不发生的</span>


## 3. DeepSeekMoE Architecture

在第2节中概述的通用MoE架构基础上，我们提出了DeepSeekMoE，它专门设计用来发挥专家专长的潜力。如图2所示，我们的架构包含了两个主要策略：细粒度专家细分和共享专家隔离。这两个策略都旨在提高专家专长的水平。

![图1](http://jinluzhang.github.io/assets/posts_img/2025-01-29-DeepSeek/deepseek-MoE-1.png)


### 3.1. Fine-Grained Expert Segmentation

在专家数量有限的情况下，分配给特定专家的tokens更可能涵盖多种类型的知识。因此，指定的专家往往会在其参数中学习到多种截然不同的知识，这些知识很难被同时利用。然而，如果每个token可以被路由到更多的专家，丰富的知识就有可能被分解并分别在不同的专家中学习。在这种情况下，每个专家仍然可以保持较高的专长性，有助于在专家之间分配更集中的知识。

为了实现这一目标，在保持专家参数数量和计算成本一致的情况下，我们对专家进行了更细的划分。更细的专家细分使得激活专家的组合更加灵活和可适应。具体来说，在图(a)所示的典型MoE架构的基础上，我们通过将FFN的中间隐藏维度缩小为原始尺寸的 m 倍，将每个专家FFN分割为 m 个更小的专家。由于每个专家变得更小，相应地，我们还增加了激活专家的数量，增加到原来的 m 倍，以保持相同的计算成本，如图(b)所示。通过细粒度的专家细分，MoE层的输出可以表示为：

$$
h_t^l = \sum_{i=1}^{mN} \left( g_{i,t} \cdot \text{FFN}_i(u_t^l) \right) + u_t^l \tag{6}
$$

$$
g_{i,t} = 
\begin{cases} 
s_{i,t}, & s_{i,t} \in \text{Topk}(\{s_{j,t} | 1 \leq j \leq mN \}, mK) \\
0, & \text{otherwise}
\end{cases}  \tag{7}
$$

$$
s_{i,t} = \text{Softmax}_i(u_t^l e_i^l)  \tag{8}
$$

通过细粒度专家细分策略，非零门控的数量也增加到了 $mK$ 。

从组合学的角度来看，细粒度专家细分策略大大增强了激活专家的组合灵活性。举个例子，假设N = 16。典型的top-2路由策略可以产生 $\binom{16}{2} = 120$ 种可能的组合。相比之下，如果每个专家被分割成4个更小的专家，细粒度路由策略可以产生 
$\binom{64}{2} = 4,426,165,368$ 种潜在的组合。组合灵活性的激增增强了实现更准确和针对性知识获取的潜力。

### 3.2. Shared Expert Isolation

在传统的路由策略下，分配给不同专家的tokens可能需要一些共享知识或信息。因此，多个专家可能会在各自的参数中收敛到获取共享知识，从而导致专家参数的冗余。然而，如果存在专门捕捉并整合不同上下文的共享知识的共享专家，那么其他路由专家之间的参数冗余将得到缓解。这种冗余的缓解将有助于构建一个更为参数高效、专家更专注的模型。

为了实现这一目标，除了细粒度专家细分策略外，我们进一步隔离了 $K_s$ 个专家作为共享专家。无论路由模块如何，每个token都会确定性地分配给这些共享专家。为了保持计算成本的恒定，其他路由专家中的激活专家数量将减少 $K_s$ ，如图(c)所示。通过集成共享专家隔离策略，完整的DeepSeekMoE架构中的MoE层可以表示如下：

$$
h_t^l = \sum_{i=1}^{K_s} \text{FFN}_i(u_t^l) + \sum_{i=1}^{mN} \left( g_{i,t} \cdot \text{FFN}_i(u_t^l) \right) + u_t^l \tag{9}
$$

$$
g_{i,t} = 
\begin{cases} 
s_{i,t}, & s_{i,t} \in \text{Topk}(\{s_{j,t} | K_s +1 \leq j \leq mN \}, mK-K_s) \\
0, & \text{otherwise}
\end{cases}  \tag{10}
$$

$$
s_{i,t} = \text{Softmax}_i(u_t^l e_i^l)  \tag{11}
$$

最后，在DeepSeekMoE中，共享专家的数量为 $K_s$ ，总的路由专家数量为 $mN - K_s$ ，而非零门控的数量为 $mK - K_s$。

值得注意的是，共享专家隔离的原型可以归功于Rajbhandari等人（2022）。关键区别在于，他们是从工程角度提出这一策略，而我们则是从算法的角度出发。

### 3.3. Load Balance Consideration

自动学习的路由策略可能会遇到负载不均衡的问题，这表现出两个显著的缺陷。首先，存在路由崩溃的风险（Shazeer等，2017），即模型总是选择少数几个专家，导致其他专家无法得到充分的训练。其次，如果专家分布在多个设备上，负载不均衡可能会加剧计算瓶颈。

**专家级负载均衡损失**  

为了缓解路由崩溃的风险，我们还采用了专家级负载均衡损失。负载均衡损失的计算公式如下：

$$
\mathcal{L}_{ExpBal} = \alpha_1 \sum_{i=1}^{N'} \mathcal{f}_i P_i, \tag{12}
$$

$$
\mathcal{f}_i = \frac{N'}{K'T} \sum_{t=1}^{T} \mathbb{1}(\text{Token} t \text{ selects Expert} i), \tag{13}
$$

$$
P_i = \frac{1}{T} \sum_{t=1}^{T} s_{i,t}, \tag{14}
$$

其中， $\alpha_1$ 是一个超参数，称为专家级负载均衡因子； $N'= mN - K_s$ ，$K' = mK - K_s$ 。 $\mathbb{1}(·)$ 表示指示函数。

**Device-Level Balance Loss**  

除了专家级负载均衡损失，我们引入了设备级负载均衡损失。在旨在缓解计算瓶颈时，强制实施严格的专家级负载均衡约束是没有必要的，因为过度约束负载均衡会影响模型性能。相反，我们的主要目标是确保设备之间的计算负载均衡。如果我们将所有路由专家分成 D 组 $\{\mathcal{E}_1, \mathcal{E}_2, ..., \mathcal{E}_D\}$ ，并将每组部署到单个设备上，则设备级负载均衡损失的计算公式如下：

$$
\mathcal{L}_{DevBal} = \alpha_2 \sum_{i=1}^{D} f'_i P'_i, \tag{15}
$$

$$
f'_i = \frac{1}{|\mathcal{E}_i|} \sum_{j \in \mathcal{E}_i} f_j, \tag{17}
$$

$$
P'_i = \sum_{j \in \mathcal{E}_i} P_j, \tag{16}
$$

其中， $\alpha_2$ 是一个超参数，称为设备级负载均衡因子。在实践中，我们设置一个较小的专家级负载均衡因子，以减轻路由崩溃的风险，同时设置一个较大的设备级负载均衡因子，以促进设备之间的负载均衡计算。


---

# DeepSeek-V2

## Abstract

DeepSeek-V2是混合专家（Mixture-of-Experts, MoE）语言模型，其特点是经济的训练和高效的推理。该模型总共有 2360 亿个参数，其中每个 token 激活 210 亿个参数，并且支持 128K token 的上下文长度。DeepSeek-V2 采用了创新的架构，包括多头潜在注意力（Multi-head Latent Attention, MLA）和 DeepSeekMoE。MLA 通过显著压缩Key-Value缓存为latent向量，保证了高效的推理，而 DeepSeekMoE 则通过稀疏计算sparse computation，使得可以经济高效的训练出strong模型。与 DeepSeek 67B 相比，DeepSeek-V2 在性能上显著提升，同时节省了 42.5% 的训练成本，减少了 93.3% 的 KV 缓存，并将最大生成吞吐量提高了 5.76 倍。我们在一个包含 8.1 万亿 token 的高质量多源语料库上对 DeepSeek-V2 进行了预训练，并进一步进行了监督微调（Supervised Fine-Tuning, SFT）和强化学习（Reinforcement Learning, RL），充分挖掘其潜力。评估结果显示，即使只有 210 亿激活参数，DeepSeek-V2 及其聊天版本在开源模型中仍然表现出色。

## 1.Introduction

在过去的几年中，大型语言模型（LLMs）（Anthropic, 2023；Google, 2023；OpenAI, 2022, 2023）经历了快速发展，为我们展现了人工通用智能（AGI）的曙光。通常，LLM 的智能随着参数数量的增加而提升，使其能够在各种任务中展示出涌现的能力（Wei et al., 2022）。然而，这种提升伴随着更大计算资源的需求，并可能导致推理吞吐量的下降。这些限制构成了显著的挑战，阻碍了 LLM 的广泛采用和利用。为了应对这一问题，我们提出了 DeepSeek-V2，一款强大的开源混合专家（Mixture-of-Experts, MoE）语言模型，采用创新的 Transformer 架构，使其训练经济、推理高效。该模型总共有 2360 亿参数，其中每个 token 激活 210 亿参数，并支持 128K token 的上下文长度。

我们优化了 Transformer 框架（Vaswani et al., 2017）中的Attention模块和前馈网络Feed-Forward Networks (FFNs)，引入了我们提出的多头潜在注意力（Multi-head Latent Attention, MLA）和 DeepSeekMoE。（1）在注意力机制的背景下，多头注意力（Multi-Head Attention, MHA）（Vaswani et al., 2017）中的键值（Key-Value, KV）缓存对 LLM 的推理效率构成了显著障碍。为了解决这个问题，已经探索了多种方法，包括分组查询注意力（Grouped-Query Attention, GQA）（Ainslie et al., 2023）和多查询注意力（Multi-Query Attention, MQA）（Shazeer, 2019）。然而，这些方法在试图减少 KV 缓存时，往往会牺牲性能。为了实现两者兼得，我们提出了 MLA，这是一种具备低秩键值联合压缩的注意力机制。从实验证据来看，MLA 相比 MHA 能够实现更优的性能，同时在推理过程中显著减少 KV 缓存，从而提升推理效率。（2）对于前馈网络（FFN），我们遵循 DeepSeekMoE 架构（Dai et al., 2024），该架构采用精细的专家分割和共享专家隔离，以提高专家专门化的潜力。与传统的 MoE 架构（如 GShard（Lepikhin et al., 2021））相比，DeepSeekMoE 架构展示了显著的优势，使我们能够以经济的成本训练强大的模型。由于我们在训练过程中采用了专家并行机制，我们还设计了补充机制来控制通信开销并确保负载均衡。通过结合这两种技术，DeepSeek-V2 同时具备了强大的性能、经济的训练成本和高效的推理吞吐量。

我们构建了一个高质量、多源的预训练语料库，包含 8.1 万亿 tokens。与 DeepSeek 67B（我们之前发布的版本）（DeepSeek-AI, 2024）所使用的语料库相比，这个语料库的数据量有所增加，尤其是中文数据，并且数据质量更高。我们首先在完整的预训练语料库上对 DeepSeek-V2 进行预训练。然后，我们收集了 150 万对话会话，涵盖了数学、代码、写作、推理、安全等多个领域，用于对 DeepSeek-V2 Chat 进行监督微调（Supervised Fine-Tuning, SFT）。最后，我们参照 DeepSeekMath（Shao et al., 2024）采用群体相对策略优化（Group Relative Policy Optimization, GRPO）进一步调整模型，以使其更符合人类偏好，并产生 DeepSeek-V2 Chat（RL）。

我们在英语和中文的一系列基准测试中评估了 DeepSeek-V2，并与代表性的开源模型进行了比较。评估结果显示，即使只有 210 亿个激活参数，DeepSeek-V2 仍然在开源模型中实现了顶级表现，成为最强的开源 MoE 语言模型。图 1(a) 显示，在 MMLU 测试中，DeepSeek-V2 在仅激活少量参数的情况下仍取得了领先的表现。此外，如图 1(b) 所示，与 DeepSeek 67B 相比，DeepSeek-V2 节省了 42.5% 的训练成本，减少了 93.3% 的 KV 缓存，并将最大生成吞吐量提升了 5.76 倍。我们还在开放式基准测试中评估了 DeepSeek-V2 Chat（SFT）和 DeepSeek-V2 Chat（RL）。值得注意的是，DeepSeek-V2 Chat（RL）在 AlpacaEval 2.0（Dubois et al., 2024）上的长度控制胜率为 38.9%，在 MT-Bench（Zheng et al., 2023）上的整体得分为 8.97，在 AlignBench（Liu et al., 2023）上的整体得分为 7.91。英语开放式对话评估表明，DeepSeek-V2 Chat（RL）在开源聊天模型中具有顶级表现。此外，在 AlignBench 上的评估结果表明，在中文环境下，DeepSeek-V2 Chat（RL）超过了所有开源模型，甚至超过了大多数闭源模型。

为了促进 MLA 和 DeepSeekMoE 的进一步研究与开发，我们还发布了 DeepSeek-V2-Lite，这是一个较小的模型，配备了 MLA 和 DeepSeekMoE，供开源社区使用。该模型总共有 157 亿个参数，每个 token 激活 24 亿个参数。关于 DeepSeek-V2-Lite 的详细描述可以在附录 B 中找到。

本文的其余部分将首先详细描述 DeepSeek-V2 的模型架构（第 2 节）。随后，我们将介绍我们的预训练工作，包括训练数据的构建、超参数设置、基础设施、长上下文扩展以及模型性能和效率的评估（第 3 节）。接下来，我们将展示我们在对齐方面的努力，包括监督微调（SFT）、强化学习（RL）、评估结果和其他讨论（第 4 节）。最后，我们总结结论，讨论 DeepSeek-V2 的当前局限性，并概述我们的未来工作（第 5 节）。



## 2.Architecture

总体来说，DeepSeek-V2 仍然采用了 Transformer 架构（Vaswani 等人，2017），其中每个 Transformer 模块由一个注意力模块和一个前馈网络（FFN）组成。然而，针对注意力模块和 FFN，我们设计并采用了创新的架构。对于注意力，我们设计了 MLA，它利用低秩的键值联合压缩来消除推理时键值缓存的瓶颈，从而支持高效的推理。对于 FFN，我们采用了 DeepSeekMoE 架构（Dai 等人，2024），这是一种高性能的 MoE 架构，能够以经济的成本训练出强大的模型。DeepSeek-V2 的架构示意图如图所示，我们将在本节中介绍 MLA 和 DeepSeekMoE 的详细信息。至于其他一些细节（例如层归一化和 FFN 中的激活函数），除非特别说明，DeepSeek-V2 遵循 DeepSeek 67B（DeepSeek-AI，2024）的设置。

![图1](http://jinluzhang.github.io/assets/posts_img/2025-01-29-DeepSeek/deepseek-v2-1.png)

### 2.1.Multi-Head Latent Attention

传统的 Transformer 模型通常采用多头注意力（MHA）（Vaswani 等人，2017），但在生成过程中，其庞大的键值缓存会成为限制推理效率的瓶颈。为了减少 KV 缓存，提出了多查询注意力（MQA）（Shazeer，2019）和分组查询注意力（GQA）（Ainslie 等人，2023）。这些方法需要更小的 KV 缓存，但它们的性能无法与 MHA 匹敌（我们在附录 D.1 中提供了 MHA、GQA 和 MQA 的消融实验）。

对于 DeepSeek-V2，我们设计了一种创新的注意力机制，称为多头潜在注意力（MLA）。MLA 通过低秩键值联合压缩，实现了比 MHA 更好的性能，同时需要显著更少的 KV 缓存。我们将在以下部分介绍其架构，并在附录 D.2 中提供 MLA 与 MHA 的对比。

![图1](http://jinluzhang.github.io/assets/posts_img/2025-01-29-DeepSeek/deepseek-v2-2.png)


#### 2.1.1 标准的多头注意力

我们首先介绍标准的 MHA 机制作为背景。记 $d$ 表示嵌入维度（embedding dimension），$n_h$ 表示注意力头的数量，$d_h$ 表示每个注意力头的维度，$\mathbf{h}_t \in \mathbb{R}^d$ 表示给定的注意力层中第t个token对应的attention输入。标准 MHA 首先通过三个矩阵 $W^Q, W^K, W^V \in \mathbb{R}^{d_h n_h \times d}$ 分别生成 $\mathbf{q}_t, \mathbf{k}_t, \mathbf{v}_t \in \mathbb{R}^{d_h n_h}$ :

$$
\mathbf{q}_t = W^Q \mathbf{h}_t, \tag{1}
$$

$$
\mathbf{k}_t = W^K \mathbf{h}_t, \tag{2}
$$

$$
\mathbf{v}_t = W^V \mathbf{h}_t, \tag{3}
$$

然后，$\mathbf{q}_t, \mathbf{k}_t, \mathbf{v}_t$ 会切成 $n_h$ 块，分别送入 $n_h$ 个多个头做计算。

$$
[\mathbf{q}_{t,1}; \mathbf{q}_{t,2}; \dots; \mathbf{q}_{t,n_h}] = \mathbf{q}_t,
$$

$$
[\mathbf{k}_{t,1}; \mathbf{k}_{t,2}; \dots; \mathbf{k}_{t,n_h}] = \mathbf{k}_t,
$$

$$
[\mathbf{v}_{t,1}; \mathbf{v}_{t,2}; \dots; \mathbf{v}_{t,n_h}] = \mathbf{v}_t, \tag{4}
$$

以第i个Attention头为例，记它第t个token对应的的k向量 $\mathbf{k}^i$ 如下，v类似。

$$
\mathbf{k}_{*,i} = [\mathbf{k}_{1,i}; \mathbf{k}_{2,i}; \dots; \mathbf{k}_{t,i}],
$$

$$
\mathbf{v}_{*,i} = [\mathbf{v}_{1,i}; \mathbf{v}_{2,i}; \dots; \mathbf{v}_{t,i}], \tag{5}
$$

然后， $\mathbf{q}_{t,i}$ 要和所有keys计算MatMul，除以 $\sqrt{d_h}$ 后计算softmax，代表对所有values的权重。

记 $\mathbf{q}_{t,i}$ 对应的输出是 $\mathbf{o}_{t,i}$ ：

$$
 \mathbf{o}_{t,i} = \text{Softmax}\left(\frac{\mathbf{q}_{t,i} \mathbf{k}_{*,i}}{\sqrt{d_h}}\right) \mathbf{v}_{*,i}, \tag{6}
$$

然后，所有 $\mathbf{o}_{t,i}$ concat在一起后乘以$W^O \in \mathbb{R}^{d \times d_h n_h}$ ，就是第t个token对应的MHA的整体输出：

$$
\mathbf{u}_t = W^O [\mathbf{o}_{t,1}; \mathbf{q}_{t,2}; \dots; \mathbf{o}_{t,n_h}], \tag{7}
$$

在推理过程中，所有的 $\mathbf{k_t}, \mathbf{v_t}$ 需要缓存以加速推理，因此在推理时，每层需要缓存 2×𝑑×sequence_length 个元素。在模型部署时，这种庞大的 KV 缓存成为了限制maximum batch和sequence length的瓶颈。

<span style="color:red">参考llama中的Attention模块详细拆解图。 https://jinluzhang.github.io/%E6%8A%80%E6%9C%AF/2023/08/02/LLAMA2-code.html 。比如我们在第T步的输入是500个token，输出了第501个token，那么继续自回归inference，在第T+1步要输入501个token，此时应该要计算这个501个token的WQ、WK、WV矩阵乘法、501个key和501个value之间的score，但前面的500个token的已经算过了，为了减少计算量，会把他们缓存下来。但这个缓存比较大，是dim X token_length大小的，本文的MLA可以减少这部分的缓存空间。注意在第T+1步中，我们的输出是第502个token，query是已知的501个token，但在这一步，只有第501个token的score是没计算过的，所以在这一步中的query一般就只记做第501个token它自己。以及，按逻辑每一层的output也要缓存的。但因为kv缓存在，下一层真正用到的未知的就只有第501个token对应的那个输出，所以output就不需要缓存了</span>

#### 2.1.2 Low-Rank Key-Value Joint Compression

MLA 的核心是对键和值进行低秩联合压缩low-rank joint compression以减少 KV 缓存：

$$
\mathbf{c}_t^{KV} = W^{DKV} \mathbf{h}_t, \tag{8}
$$

$$
\mathbf{k}_t^C = W^{UK} \mathbf{c}_t^{KV}, \tag{9}
$$

$$
\mathbf{v}_t^C = W^{UV} \mathbf{c}_t^{KV}, \tag{10}
$$
 
其中， $\mathbf{c}_t^{KV} \in \mathbb{R}^{d_c}$ 是压缩后的latent向量， $W^{DKV} \in \mathbb{R}^{d_c \times d}$ 为down-projection下投影矩阵； $W^{UK}, W^{UV} \in \mathbb{R}^{d_h n_h \times d_c}$ 分别为key和value的上投影矩阵。

在推理过程中，MLA 仅需要缓存 $\mathbf{c}_t^{KV}$ ，因此其 KV 缓存只有 $d_c$ ×sequence_length个元素。
此外，在推理时，由于 $W^{UK}$ 可以合并进 $W^Q$ 中，$W^{UV}$ 可以合并进 $W^O$ 中，因此我们甚至无需付出额外更多的计算。

<span style="color:red">原本第一反应这是时间换空间，在MHA里，$W^K \mathbf{h}_t$ 和 $W^V \mathbf{h}_t$ 是不用计算的，结果已经被缓存了。但是MLA需要多算两次up-projection： $W^{UK} \mathbf{c}_t^{KV}$ 、 $W^{UV} \mathbf{c}_t^{KV}$  。 但巧妙在参数矩阵可以合并，并且合并后，对应的 $W^Q$ 和 $W^O$ size也降低了，和MHA相比inference时候的计算量也降低了。（训练的时候没有做这个合并，所以逻辑上参数空间没有被压缩，模型的表达能力没有被压缩）。</span>

为了减少训练过程中的激活内存，我们还对query进行了低秩压缩（就是对 $W^Q$ 做了低秩压缩分解，实际上参数量变少了，模型表达能力按道理也降低了），尽管这不能减少 KV 缓存：

$$
\mathbf{c}_t^Q = W^{DQ} \mathbf{h}_t, \tag{11}
$$

$$
\mathbf{q}_t^C = W^{UQ} \mathbf{c}_t^Q, \tag{12}
$$


#### 2.1.3. Decoupled Rotary Position Embedding

延续 DeepSeek 67B（DeepSeek-AI，2024），我们想在 DeepSeek-V2 中也使用旋转位置嵌入（Rotary Position Embedding，RoPE）（Su 等人，2024）。然而，RoPE 与低秩键值压缩不兼容。具体而言，RoPE 对于keys和queries都是位置敏感的。如果我们将 RoPE 应用于 $\mathbf{k}_t^C$ ，那么公式（9）中的 $W^{UK}$ 将与一个位置敏感的 RoPE 矩阵耦合。这样，在推理过程中，它就无法再被合并到 $W^Q$ 中，因为与当前正在生成的token相关的 RoPE 矩阵位于 $W^Q$ 和 $W^{UK}$ 之间，而矩阵乘法并不满足交换律。因此，我们必须在推理过程中重新计算所有前序token的keys，这将显著影响推理效率。

为了解决这个问题，我们提出了一种解耦 RoPE 策略，该策略使用额外的多头queries  $\mathbf{q}_{t,i}^R \in \mathbb{R}^{d_h^R}$ 和一个共享key  $\mathbf{k}_t^R \in \mathbb{R}^{d_h^R}$ 来携带RoPE信息，其中 $d_h^R$ 代表每个头中，解耦了的queries和key的维度大小。通过 RoPE 解耦策略，MLA 执行以下计算：

$$
 [ \mathbf{q}_{t,1}^R; \mathbf{q}_{t,2}^R; \dots; \mathbf{q}_{t,n_h}^R] = \mathbf{q}_t^R = \text{RoPE}(W^{QR} \mathbf{c}_t^Q) = \text{RoPE}(W^{QR} W^{DQ} \mathbf{h}_t), \tag{13}
$$

$$
\mathbf{k}_t^R = \text{RoPE}(W^{KR} \mathbf{h}_t), \tag{14}
$$

$$
\mathbf{q}_{t,i} = [\mathbf{q}_{t,i}^C; \mathbf{q}_{t,i}^R],
$$

$$
\mathbf{k}_{t,i} = [\mathbf{k}_{t,i}^C; \mathbf{k}_{t}^R], \tag{15}
$$

$$
 \mathbf{o}_{t,i} = \text{Softmax}\left(\frac{\mathbf{q}_{t,i} \mathbf{k}_{*,i}}{\sqrt{d_h + d_h^R}}\right) \mathbf{v}_{*,i}^C, \tag{16}
$$

$$
\mathbf{u}_t = W^O [\mathbf{o}_{t,1}; \mathbf{q}_{t,2}; \dots; \mathbf{o}_{t,n_h}], \tag{17}
$$

在推理过程中，解耦的key也需要缓存，即公式14对应的 $\mathbf{k}_t^R$ 。


### 2.2. DeepSeekMoE: Training Strong Models at Economical Costs

#### 2.2.1. Basic Architecture

见本文单独的DeepSeekMoE论文部分，内容更详细些。

#### 2.2.2. Device-Limited Routing

我们设计了一种设备限制路由机制，以限制MoE相关的通信成本。当采用专家并行时，路由专家将分布在多个设备上。对于每个token，其MoE相关的通信频率与其目标专家所覆盖的设备数量成正比。由于DeepSeekMoE中的细粒度专家细分，激活的专家数量可能很大，因此如果应用专家并行，MoE相关的通信成本将增加。

对于DeepSeek-V2，除了简单的top-K路由专家选择外，我们还确保每个token的目标专家最多分布在 M 个设备上。具体来说，对于每个token，我们首先选择 M 个设备，这些设备中包含亲和度分数最高的专家。然后，我们在这些 M 个设备上执行top-K选择。实际上，我们发现当 $M \geq 3$ 时，设备限制路由可以实现与无限制top-K路由大致一致的良好性能。

#### 2.2.3. Auxiliary Loss for Load Balance

我们考虑了自动学习的路由策略中的负载均衡问题。首先，负载不均衡将增加路由崩溃的风险（Shazeer等人，2017），阻止一些专家得到充分训练和利用。其次，当采用专家并行时，负载不均衡将降低计算效率。在DeepSeek-V2的训练过程中，我们设计了三种辅助损失，分别用于控制专家级负载均衡（LExpBal）、设备级负载均衡（LDevBal）和通信均衡（LCommBal）。

前两种损失见前文DeepSeekMoE论文部分。

**Communication Balance Loss**  
最后，我们引入了通信均衡损失，以确保每个设备的通信负载均衡。尽管设备限制路由机制保证了每个设备的发送通信是有上限的，但如果某个设备接收到的token数量超过其他设备，实际的通信效率也会受到影响。为了减轻这个问题，我们设计了一个通信均衡损失，公式如下：

$$
\mathcal{L}_{CommBal} = \alpha_3 \sum_{i=1}^{D} f''_i P''_i, \tag{29}
$$

$$
\mathcal{f}''_i = \frac{D}{MT} \sum_{t=1}^{T} \mathbb{1}(\text{Token} t \text{is sent to Device} i), \tag{30}
$$

$$
P''_i = \sum_{j \in \mathcal{E}_i} P_j, \tag{31}
$$

其中， $\alpha_3$ 是一个超参数，称为通信均衡因子。设备限制路由机制的操作原则是确保每个设备最多向其他设备传输𝑀𝑇个隐藏状态。与此同时，通信均衡损失也鼓励每个设备从其他设备接收大约𝑀𝑇个隐藏状态。通信均衡损失确保了设备之间信息交换的均衡，促进了高效的通信。

#### 2.2.4. Token-Dropping Strategy

虽然负载均衡损失旨在鼓励负载均衡，但需要注意的是，它们无法保证严格的负载均衡。为了进一步减轻由于负载不均衡导致的计算浪费，我们在训练过程中引入了设备级的token丢弃策略。该方法首先计算每个设备的平均计算预算，这意味着每个设备的容量因子等于1.0。然后，受到Riquelme等人（2021年）的启发，我们丢弃每个设备上亲和度最低的tokens，直到达到计算预算。此外，我们确保大约10%的训练序列中的tokens永远不会被丢弃。通过这种方式，我们可以根据推理过程中的效率要求灵活地决定是否丢弃tokens，并始终确保训练与推理之间的一致性。

## 3. Pre-Training

### 3.1. Experimental Setups

#### 3.1.1. Data Construction

在保持与DeepSeek 67B（DeepSeek-AI，2024）相同的数据处理阶段的基础上，我们扩展了数据量并提升了数据质量。为了扩大我们的预训练语料库，我们探索了互联网数据的潜力，并优化了数据清洗过程，从而恢复了大量误删的数据。此外，我们还加入了更多中文数据，旨在更好地利用中文互联网可用的语料库。除了数据量，我们还关注数据质量。我们通过多种来源的高质量数据来丰富我们的预训练语料库，并同时改进了基于质量的过滤算法。改进后的算法确保会移除大量无益数据，同时大部分有价值的数据将被保留。此外，我们从预训练语料库中剔除了有争议的内容，以减少特定区域文化所引入的数据偏差。 

我们采用与DeepSeek 67B相同的分词器，该分词器基于字节级字节对编码（BBPE）算法构建，词表大小为100K。我们的分词预训练语料库包含8.1万亿个token，其中中文token比英文token多约12%。

#### 3.1.2. Hyper-Parameters

**Model Hyper-Parameters**

我们将Transformer层数设置为60，隐藏维度设置为5120。所有可学习的参数使用标准差为0.006的方式进行随机初始化。在MLA中，我们将注意力头数 $n_h$ 设置为128，每个头的维度 $d_h$ 设置为128。KV压缩维度 $d_c$ 设置为512，查询压缩维度 $d_c'$ 设置为1536。对于解耦查询和键，我们将每个头的维度 $d_R$ 设置为64。

根据Dai等（2024）的研究，我们将除了第一层之外的所有FFN替换为MoE层。每个MoE层由2个共享专家和160个路由专家组成，每个专家的中间隐藏维度为1536。在路由专家中，每个token将激活6个专家。此外，低秩压缩和细粒度专家细分将影响层的输出规模。因此，实际上，我们在压缩的潜在向量后面使用了额外的RMS Norm层，并在宽度瓶颈处（即压缩的潜在向量和路由专家的中间隐藏状态）乘上额外的缩放因子，以确保训练的稳定性。在此配置下，DeepSeek-V2包含236B总参数，其中每个token激活21B参数。

**Training Hyper-Parameters**

我们使用AdamW优化器（Loshchilov和Hutter，2017），其超参数设置为 $\beta_1 = 0.9$ ， $\beta_2 = 0.95$ ，权重衰减为0.1。学习率使用热身和逐步衰减策略进行调度（DeepSeek-AI，2024）。最初，学习率在前2K步内线性从0增加到最大值。随后，学习率在训练约60%的tokens后乘以0.316，在训练约90%的tokens后再乘以0.316。最大学习率设置为2.4 × 10⁻⁴，梯度裁剪范数设置为1.0。我们还使用了批量大小调度策略，其中在前225B tokens的训练过程中，批量大小从2304逐渐增加到9216，然后在剩余的训练中保持9216。我们将最大序列长度设置为4K，并在8.1T的tokens上训练DeepSeek-V2。我们利用管道并行性将模型的不同层部署到不同的设备上，对于每一层，路由专家将均匀部署到8个设备上（D = 8）。对于设备限制路由，每个token将被发送到最多3个设备上（ M = 3 ）。关于负载均衡损失，我们将 $\alpha_1$ 设置为0.003， $\alpha_2$ 设置为0.05， $\alpha_3$ 设置为0.02。在训练过程中我们使用token丢弃策略来加速，但在评估时不丢弃任何token。

#### 3.1.3. Infrastructures

DeepSeek-V2是在HAI-LLM框架（High-flyer，2023）上训练的，这是由我们工程师内部开发的一个高效且轻量的训练框架。它采用16路zero-bubble pipeline parallelism（Qi等，2023）、8路expert parallelism（Lepikhin等，2021）和ZeRO-1数据并行（Rajbhandari等，2020）。由于DeepSeek-V2激活的参数相对较少，并且部分操作会重新计算以节省激活内存，因此可以在不需要张量并行的情况下进行训练，从而减少通信开销。此外，为了进一步提高训练效率，我们将共享专家的计算与专家并行的all-to-all通信进行重叠。我们还定制了更快的CUDA内核，用于不同专家之间的通信、路由算法和融合线性计算。此外，MLA还基于改进版的FlashAttention-2（Dao，2023）进行了优化。

我们在配备NVIDIA H800 GPU的集群上进行所有实验。H800集群中的每个节点包含8个GPU，这些GPU通过节点内部的NVLink和NVSwitch连接。节点间使用InfiniBand互连进行通信。

#### 3.1.4. Long Context Extension

在DeepSeek-V2的初步预训练之后，我们采用YaRN（Peng等，2023）将默认的上下文窗口长度从4K扩展到128K。YaRN特别应用于解耦共享键 $k_t^R$ ，因为它负责携带RoPE（Su等，2024）。对于YaRN，我们设置了比例 s 为40， $\alpha$ 为1， $\beta$ 为32，目标最大上下文长度为160K。在这些设置下，我们可以预期模型能够很好地响应128K的上下文长度。略微偏离原始YaRN，由于我们的独特注意力机制，我们调整了长度缩放因子 $\sqrt{t}$ 来调节注意力熵。因子 t 计算为 $\sqrt{t} = 0.0707 \ln s + 1$ ，旨在最小化困惑度perplexity。

我们还额外训练了1000步，序列长度为32K，批量大小为576个序列。尽管训练仅在32K的序列长度下进行，但当在128K的上下文长度下进行评估时，模型仍然表现出强大的性能。

### 3.2. Evaluations

#### 3.2.1. Evaluation Benchmarks

DeepSeek-V2在双语语料库上进行了预训练，因此我们在一系列英中文基准上进行评估。我们的评估基于集成在HAI-LLM框架中的内部评估框架。包含的基准按类别列出，如下所示，其中下划线标记的基准为中文数据集：

- **多学科选择题数据集**：包括MMLU（Hendrycks等，2020），C-Eval（Huang等，2023），和CMMLU（Li等，2023）。
- **语言理解与推理数据集**：包括HellaSwag（Zellers等，2019），PIQA（Bisk等，2020），ARC（Clark等，2018），和BigBench Hard（BBH）（Suzgun等，2022）。
- **闭卷问答数据集**：包括TriviaQA（Joshi等，2017）和NaturalQuestions（Kwiatkowski等，2019）。
- **阅读理解数据集**：包括RACE（Lai等，2017），DROP（Dua等，2019），C3（Sun等，2019），和CMRC（Cui等，2019）。
- **参考歧义消解数据集**：包括WinoGrande（Sakaguchi等，2019）和CLUEWSC（Xu等，2020）。
- **语言建模数据集**：包括Pile（Gao等，2020）。
- **中文理解与文化数据集**：包括CHID（Zheng等，2019）和CCPM（Li等，2021）。
- **数学数据集**：包括GSM8K（Cobbe等，2021），MATH（Hendrycks等，2021），和CMath（Wei等，2023）。
- **代码数据集**：包括HumanEval（Chen等，2021），MBPP（Austin等，2021），和CRUXEval（Gu等，2024）。
- **标准化考试**：包括AGIEval（Zhong等，2023）。注意，AGIEval包括英文和中文子集。

根据我们之前的工作（DeepSeek-AI，2024），我们对包括HellaSwag、PIQA、WinoGrande、RACE-Middle、RACE-High、MMLU、ARC-Easy、ARC-Challenge、CHID、C-Eval、CMMLU、C3和CCPM的数据集采用基于困惑度的评估，对于TriviaQA、NaturalQuestions、DROP、MATH、GSM8K、HumanEval、MBPP、CRUXEval、BBH、AGIEval、CLUEWSC、CMRC和CMath的数据集则采用基于生成的评估。此外，我们对Pile-test进行了基于语言建模的评估，并使用字节每位（BPB）作为度量标准，以确保不同token化器之间模型的公平比较。

为了直观地展示这些基准，我们还在附录G中提供了每个基准的评估格式。

#### 3.2.2. Evaluation Results

在表2中，我们将DeepSeek-V2与几种代表性的开源模型进行了比较，包括DeepSeek 67B（DeepSeek-AI，2024）（我们之前发布的版本）、Qwen1.5 72B（Bai等，2023）、LLaMA3 70B（AI@Meta，2024）和Mixtral 8x22B（Mistral，2024）。我们使用我们的内部评估框架对这些模型进行评估，并确保它们共享相同的评估设置。总体而言，在只有21B激活参数的情况下，DeepSeek-V2在几乎所有基准上显著超越了DeepSeek 67B，并且在开源模型中表现出色。

进一步地，我们逐一与开源对手进行详细比较。(1) 与Qwen1.5 72B相比，Qwen1.5 72B是另一个支持中英文的模型，DeepSeek-V2在大多数英语、代码和数学基准上表现出压倒性的优势。对于中文基准，Qwen1.5 72B在多学科选择题任务上表现更好，而DeepSeek-V2在其他任务上的表现可比或更优。需要注意的是，对于CHID基准，Qwen1.5 72B的tokenizer在我们的评估框架中会出现错误，因此我们未显示Qwen1.5 72B的CHID分数。(2) 与Mixtral 8x22B相比，DeepSeek-V2在英语性能上表现可比或更好，除了TriviaQA、NaturalQuestions和HellaSwag，这些与英语常识知识紧密相关。值得注意的是，DeepSeek-V2在MMLU上超过了Mixtral 8x22B。在代码和数学基准上，DeepSeek-V2与Mixtral 8x22B的表现相当。由于Mixtral 8x22B未专门在中文数据上进行训练，因此它在中文能力上远远落后于DeepSeek-V2。(3) 与LLaMA3 70B相比，DeepSeek-V2的训练使用的英文tokens不到LLaMA3 70B的四分之一。因此，我们承认DeepSeek-V2在基本英语能力上仍略逊于LLaMA3 70B。然而，尽管训练tokens和激活参数少得多，DeepSeek-V2在代码和数学能力上仍与LLaMA3 70B相当。此外，作为一个双语语言模型，DeepSeek-V2在中文基准上压倒性地超越了LLaMA3 70B。

最后，值得一提的是，某些先前的研究（Hu等，2024）在预训练阶段纳入了SFT数据，而DeepSeek-V2在预训练期间从未接触过SFT数据。

#### 3.2.3. Training and Inference Efficiency

**Training Costs**  

由于DeepSeek-V2每个token激活的参数较少，所需的FLOPs也比DeepSeek 67B少，因此从理论上讲，训练DeepSeek-V2将比训练DeepSeek 67B更为经济。尽管训练MoE模型会引入额外的通信开销，但通过我们的操作和通信优化，DeepSeek-V2的训练可以实现较高的模型FLOPs利用率（MFU）。在我们实际在H800集群上的训练中，每训练一万亿个tokens，DeepSeek 67B需要300.6K GPU小时，而DeepSeek-V2仅需要172.8K GPU小时，即稀疏的DeepSeek-V2相比于密集的DeepSeek 67B节省了42.5%的训练成本。

**Inference Efficiency.**  

为了高效地部署DeepSeek-V2进行服务，我们首先将其参数转换为FP8精度。此外，我们还对DeepSeek-V2进行了KV缓存量化（Hooper等，2024；Zhao等，2023），进一步将其KV缓存中的每个元素平均压缩为6位。得益于MLA和这些优化，实际部署的DeepSeek-V2所需的KV缓存比DeepSeek 67B显著少，因此能够支持更大的批量大小。我们基于实际部署的DeepSeek 67B服务中的提示和生成长度分布，评估了DeepSeek-V2的生成吞吐量。在单节点8个H800 GPU上，DeepSeek-V2的生成吞吐量超过50K tokens每秒，是DeepSeek 67B最大生成吞吐量的5.76倍。此外，DeepSeek-V2的提示输入吞吐量超过100K tokens每秒。

## 4. Alignment

### 4.1. Supervised Fine-Tuning

基于我们之前的研究（DeepSeek-AI，2024），我们精心挑选了我们的指令微调数据集，包含150万个实例，其中120万个实例用于有用性评估，30万个实例用于安全性评估。与初版相比，我们提高了数据质量，旨在减少虚假回应并增强写作能力。我们使用2个epoch对DeepSeek-V2进行微调，学习率设置为5 × 10⁻⁶。对于DeepSeek-V2 Chat（SFT）的评估，我们主要包括基于生成的基准，除了几个代表性的选择题任务（MMLU和ARC）。我们还对DeepSeek-V2 Chat（SFT）进行了指令跟随评估（IFEval）（Zhou等，2023），使用提示级松散准确度作为度量标准。此外，我们使用2023年9月1日至2024年4月1日的LiveCodeBench（Jain等，2024）问题来评估聊天模型。除了标准基准外，我们还在开放式对话基准上进一步评估了我们的模型，包括MT-Bench（Zheng等，2023）、AlpacaEval 2.0（Dubois等，2024）和AlignBench（Liu等，2023）。为了比较，我们还在我们的评估框架和设置中评估了Qwen1.5 72B Chat、LLaMA-3-70B Instruct和Mistral-8x22B Instruct。至于DeepSeek 67B Chat，我们直接参考了我们之前发布的评估结果。

### 4.2. Reinforcement Learning

为了进一步激发DeepSeek-V2的潜力并使其与人类偏好对齐，我们进行了强化学习（RL）以调整其偏好。

**Reinforcement Learning Algorithm**  

为了节省RL训练的成本，我们采用了Group Relative Policy Optimization（GRPO）（Shao等，2024），该方法省略了通常与policy model大小相同的critic model，而是通过组分数来估计baseline。具体来说，对于每个问题 q ，GRPO从旧的策略 $\pi_{\theta_{old}}$ 中抽取一组输出 $\{o_1, o_2, \cdots, o_G\}$ ，然后通过最大化以下目标来优化策略模型 $\pi_{\theta}$ ：

$$
\mathcal{J}_{GRPO}(\theta) = \mathbb{E}\left[q \sim P(Q), \{o_i\}_{i=1}^G \sim \pi_{\theta_{old}}(O|q)\right] \\
\frac{1}{G} \sum_{i=1}^G \left( \min \left( 
\frac{\pi_{\theta}(o_i|q)}{\pi_{\theta_{old}}(o_i|q)} A_i, 
\text{clip}\left(\frac{\pi_{\theta}(o_i|q)}{\pi_{\theta_{old}}(o_i|q)}, 1 - \epsilon, 1 + \epsilon \right) A_i
\right) 
- \beta \mathcal{D}_{KL}(\pi_{\theta} || \pi_{ref}) \right) , \tag{32}
$$

$$
\mathcal{D}_{KL}(\pi_{\theta} || \pi_{ref}) = 
\frac{\pi_{ref}(o_i|q)}{\pi_{\theta}(o_i|q)} - \log \frac{\pi_{ref}(o_i|q)}{\pi_{\theta}(o_i|q)} - 1,
\tag{33}
$$

其中 $\epsilon$ 和 $\beta$ 是超参数， $A_i$ 是每组奖励的优势计算公式：

$$
A_i = \frac{r_i - \text{mean}(\{r_1, r_2, \cdots, r_G\})}{\text{std}(\{r_1, r_2, \cdots, r_G\})}.
\tag{34}
$$

**Training Strategy.**

在我们的初步实验中，我们发现代码和数学提示等推理数据的RL训练表现出与一般数据训练不同的独特特点。例如，我们模型的数学和编码能力可以在更长时间的训练步骤中不断提高。因此，我们采用了两阶段的RL训练策略，首先进行推理对齐，然后进行人类偏好对齐。在第一个推理对齐阶段，我们训练了一个奖励模型 $RM_{reasoning}$ ，用于代码和数学推理任务，并通过它的反馈优化策略模型：

$$
r_i = RM_{reasoning}(o_i). \tag{35}
$$

在第二个人类偏好对齐阶段，我们采用了multi-reward多奖励框架，三个奖励模型分别是：helpful奖励模型 $RM_{helpful}$ 、安全奖励模型 $RM_{safety}$ 和基于规则的奖励模型 $RM_{rule}$ 来获得奖励。一个回应 $o_i$ 的最终奖励为：

$$
r_i = c_1 \cdot RM_{helpful}(o_i) + c_2 \cdot RM_{safety}(o_i) + c_3 \cdot RM_{rule}(o_i), \tag{36}
$$

其中，$c_1$ 、 $c_2$ 和 $c_3$ 是相应的系数。

为了获得可靠的奖励模型，这些模型在RL训练中发挥着关键作用，我们精心收集了偏好数据，并细致地进行质量过滤和比例调整。我们基于编译器反馈获取了代码偏好数据，基于真实标签获取了数学偏好数据。对于奖励模型的训练，我们用DeepSeek-V2 Chat（SFT）初始化奖励模型，并通过点对点损失或成对损失进行训练。在我们的实验中，我们观察到，RL训练可以充分激发模型的潜力，使其能够从可能的回答中选择正确且令人满意的答案。

**Optimizations for Training Efficiency**

在极大型模型上进行强化学习（RL）训练对训练框架提出了高要求。它需要精心的工程优化，以管理GPU内存和RAM压力，同时保持快速的训练速度。为此，我们实现了以下工程优化：(1) 首先，我们提出了一种混合引擎，对训练和推理采用了不同的并行策略，以实现更高的GPU利用率。(2) 其次，我们利用vLLM（Kwon等，2023）并使用较大的batch size作为我们的推理后端，以加速推理速度。(3) 第三，我们精心设计了模型卸载到CPU并重新加载回GPU的调度策略，从而在训练速度和内存消耗之间实现近乎最优的平衡。

### 4.3. Evaluation Results

**在标准基准上的评估**  

首先，我们在标准基准上评估了DeepSeek-V2 Chat（SFT）和DeepSeek-V2 Chat（RL）。值得注意的是，DeepSeek-V2 Chat（SFT）相比其基础版本，在GSM8K、MATH和HumanEval评估中显示出了显著的改进。这一进展可归因于我们SFT数据的引入，其中包含了大量的数学和代码相关内容。此外，DeepSeek-V2 Chat（RL）进一步提升了数学和代码基准上的性能。我们在附录F中展示了更多的代码和数学评估。

在与其他模型的比较中，我们首先将DeepSeek-V2 Chat（SFT）与Qwen1.5 72B Chat进行比较，发现DeepSeek-V2 Chat（SFT）在几乎所有英语、数学和代码基准上都超越了Qwen1.5 72B Chat。在中文基准上，DeepSeek-V2 Chat（SFT）在多学科选择题任务上的得分略低于Qwen1.5 72B Chat，与它们的基础版本的表现一致。与最先进的开源MoE模型Mixtral 8x22B Instruct相比，DeepSeek-V2 Chat（SFT）在大多数基准上表现更好，除了NaturalQuestions和IFEval。此外，与最先进的开源模型LLaMA3 70B Chat相比，DeepSeek-V2 Chat（SFT）在代码和数学相关基准上显示出类似的表现。LLaMA3 70B Chat在MMLU和IFEval上的表现更好，而DeepSeek-V2 Chat（SFT）在中文任务上表现更强。最终，DeepSeek-V2 Chat（RL）相比于DeepSeek-V2 Chat（SFT）在数学和编码任务上表现出进一步增强的性能。这些比较突出了DeepSeek-V2 Chat在各个领域和语言中相较于其他语言模型的优势。

**在开放式生成上的评估**  

我们继续在开放式对话基准上对模型进行评估。对于英语开放式对话生成，我们使用MT-Bench和AlpacaEval 2.0作为基准。表4中展示的评估结果表明，DeepSeek-V2 Chat（RL）在生成吞吐量上相比于DeepSeek-V2 Chat（SFT）具有显著的性能优势。这一结果展示了我们的RL训练在实现更好对齐方面的有效性。与其他开源模型比较，DeepSeek-V2 Chat（RL）在两个基准上均表现优于Mixtral 8x22B Instruct和Qwen1.5 72B Chat。与LLaMA3 70B Instruct相比，DeepSeek-V2 Chat（RL）在MT-Bench上表现出竞争力，并在AlpacaEval 2.0上显著超越它。这些结果凸显了DeepSeek-V2 Chat（RL）在生成高质量且与上下文相关的回答方面的强大表现，尤其是在基于指令的对话任务中。

此外，我们基于AlignBench评估了中文开放式生成能力。如表5所示，DeepSeek-V2 Chat（RL）相比于DeepSeek-V2 Chat（SFT）表现出轻微的优势。值得注意的是，DeepSeek-V2 Chat（SFT）在所有开源中文模型中表现最好，显著超越了排名第二的开源模型Qwen1.5 72B Chat，尤其是在中文推理和语言理解上。此外，DeepSeek-V2 Chat（SFT）和DeepSeek-V2 Chat（RL）均超越了GPT-4-0613和ERNIEBot 4.0，巩固了我们模型在支持中文的顶级LLM中的地位。具体而言，DeepSeek-V2 Chat（RL）在中文语言理解方面表现出色，超越了包括GPT-4-Turbo-1106-Preview在内的所有模型。另一方面，DeepSeek-V2 Chat（RL）的推理能力仍然落后于一些大型模型，如Erniebot-4.0和GPT-4s。

## 5. Conclusion, Limitation, and Future Work

本文介绍了DeepSeek-V2，一种支持128K上下文长度的大型MoE语言模型。除了强大的性能外，它还具有经济的训练和高效的推理，得益于其创新的架构，包括MLA和DeepSeekMoE。实际上，与DeepSeek 67B相比，DeepSeek-V2显著提升了性能，同时节省了42.5%的训练成本，减少了93.3%的KV缓存，并将最大生成吞吐量提升至5.76倍。评估结果进一步表明，DeepSeek-V2在仅激活21B参数的情况下，达到了开源模型中的顶级性能，成为最强的开源MoE模型。

DeepSeek-V2及其聊天版本与其他大型语言模型（LLM）共享一些公认的局限性，包括训练后缺乏持续的知识更新、可能生成未经验证的非事实信息如建议，以及可能出现幻觉的风险。此外，由于我们的数据主要由中文和英文内容构成，因此我们的模型在其他语言上可能表现有限。在中文和英文以外的场景中，应谨慎使用。

DeepSeek将继续以长期主义的视角投资于开源大型模型，旨在逐步接近人工通用智能的目标。
- 在我们持续的探索中，我们致力于制定方法，进一步扩展MoE模型，同时保持经济的训练和推理成本。下一步的目标是使我们的模型在即将发布的版本中达到与GPT-4相当的性能。
- 我们的对齐团队持续努力提升我们的模型，旨在开发出一个不仅有用且诚实、安全的模型，服务全球用户。我们的终极目标是将模型的价值观与人类价值观对齐，同时最大限度地减少人工监督的需求。通过优先考虑伦理问题和负责任的开发，我们致力于在社会中创造积极且有益的影响。
- 目前，DeepSeek-V2仅支持文本模态。 在我们前瞻性的计划中，我们打算使我们的模型支持多模态，以增强其在更广泛场景中的多样性和实用性。


## 例子-DeepSeek-V2-Lite

以DeepSeek-V2-Lite模型为例，模型定义：https://huggingface.co/deepseek-ai/DeepSeek-V2-Lite/blob/main/modeling_deepseek.py

关键参数如下。

模型Total Params=16B，Activated Params=2.4B，Context Length=32k

```python

        vocab_size=102400,
        hidden_size=4096,
        intermediate_size=11008,
        moe_intermediate_size = 1407,
        num_hidden_layers=30,
        num_attention_heads=32,
        num_key_value_heads=32,
        n_shared_experts = None,
        n_routed_experts = None,
        ep_size = 1,
        routed_scaling_factor = 1.0,
        kv_lora_rank = 512,
        q_lora_rank = 1536,
        qk_rope_head_dim = 64,
        v_head_dim = 128,
        qk_nope_head_dim = 128,
        topk_method = 'gready',
        n_group = None,
        topk_group = None,
        num_experts_per_tok = None,
        moe_layer_freq = 1,
        first_k_dense_replace = 0,
        norm_topk_prob = False,
        scoring_func = 'softmax',
        aux_loss_alpha = 0.001,
        seq_aux = True,
        hidden_act="silu",
        max_position_embeddings=2048,
        initializer_range=0.02,
        rms_norm_eps=1e-6,
        use_cache=True,
        pad_token_id=None,
        bos_token_id=100000,
        eos_token_id=100001,
        pretraining_tp=1,
        tie_word_embeddings=False,
        rope_theta=10000.0,
        rope_scaling=None,
        attention_bias=False,
        attention_dropout=0.0

{
  "architectures": [
    "DeepseekV2ForCausalLM"
  ],
  "attention_bias": false,
  "attention_dropout": 0.0,
  "auto_map": {
    "AutoConfig": "configuration_deepseek.DeepseekV2Config",
    "AutoModel": "modeling_deepseek.DeepseekV2Model",
    "AutoModelForCausalLM": "modeling_deepseek.DeepseekV2ForCausalLM"
  },
  "aux_loss_alpha": 0.001,
  "bos_token_id": 100000,
  "eos_token_id": 100001,
  "first_k_dense_replace": 1,
  "hidden_act": "silu",
  "hidden_size": 2048,
  "initializer_range": 0.02,
  "intermediate_size": 10944,
  "kv_lora_rank": 512,
  "max_position_embeddings": 163840,
  "model_type": "deepseek_v2",
  "moe_intermediate_size": 1408,
  "moe_layer_freq": 1,
  "n_group": 1,
  "n_routed_experts": 64,
  "n_shared_experts": 2,
  "norm_topk_prob": false,
  "num_attention_heads": 16,
  "num_experts_per_tok": 6,
  "num_hidden_layers": 27,
  "num_key_value_heads": 16,
  "pretraining_tp": 1,
  "q_lora_rank": null,
  "qk_nope_head_dim": 128,
  "qk_rope_head_dim": 64,
  "rms_norm_eps": 1e-06,
  "rope_scaling": {
    "beta_fast": 32,
    "beta_slow": 1,
    "factor": 40,
    "mscale": 0.707,
    "mscale_all_dim": 0.707,
    "original_max_position_embeddings": 4096,
    "type": "yarn"
  },
  "rope_theta": 10000,
  "routed_scaling_factor": 1.0,
  "scoring_func": "softmax",
  "seq_aux": true,
  "tie_word_embeddings": false,
  "topk_group": 1,
  "topk_method": "greedy",
  "torch_dtype": "bfloat16",
  "transformers_version": "4.33.1",
  "use_cache": true,
  "v_head_dim": 128,
  "vocab_size": 102400
}
```

模型结构及每一个参数矩阵的具体size如下。layer.1到layer.26结构一样；每个layer里，experts.0到experts.63结构一样。

```python
{
  "metadata": {
    "total_size": 31412968448
  },
  "weight_map": {
    "model.embed_tokens.weight": {"dtype":"BF16","shape":[102400,2048]},
    "model.norm.weight": {"dtype":"BF16","shape":[2048]},
    "lm_head.weight": {"dtype":"BF16","shape":[102400,2048]},

    "model.layers.0.self_attn.q_proj.weight": {"dtype":"BF16","shape":[3072,2048]},
    "model.layers.0.self_attn.kv_a_proj_with_mqa.weight": {"dtype":"BF16","shape":[576,2048]},
    "model.layers.0.self_attn.kv_a_layernorm.weight": {"dtype":"BF16","shape":[512]},
    "model.layers.0.self_attn.kv_b_proj.weight": {"dtype":"BF16","shape":[4096,512]},
    "model.layers.0.self_attn.o_proj.weight": {"dtype":"BF16","shape":[2048,2048]},
    "model.layers.0.mlp.gate_proj.weight": {"dtype":"BF16","shape":[10944,2048]},
    "model.layers.0.mlp.up_proj.weight": {"dtype":"BF16","shape":[10944,2048]},
    "model.layers.0.mlp.down_proj.weight": {"dtype":"BF16","shape":[2048,10944]},
    "model.layers.0.input_layernorm.weight": {"dtype":"BF16","shape":[2048]},
    "model.layers.0.post_attention_layernorm.weight": {"dtype":"BF16","shape":[2048],
    "model.layers.1.self_attn.q_proj.weight": {"dtype":"BF16","shape":[3072,2048]},
    "model.layers.1.self_attn.kv_a_proj_with_mqa.weight": {"dtype":"BF16","shape":[576,2048]},
    "model.layers.1.self_attn.kv_a_layernorm.weight": {"dtype":"BF16","shape":[512]},
    "model.layers.1.self_attn.kv_b_proj.weight": {"dtype":"BF16","shape":[4096,512]},
    "model.layers.1.self_attn.o_proj.weight": {"dtype":"BF16","shape":[2048,2048]},
    "model.layers.1.mlp.gate.weight": {"dtype":"BF16","shape":[64,2048]},
    "model.layers.1.mlp.shared_experts.gate_proj.weight": {"dtype":"BF16","shape":[2816,2048]},
    "model.layers.1.mlp.shared_experts.up_proj.weight": {"dtype":"BF16","shape":[2816,2048]},
    "model.layers.1.mlp.shared_experts.down_proj.weight": {"dtype":"BF16","shape":[2048,2816]},
    "model.layers.1.mlp.experts.0.gate_proj.weight": {"dtype":"BF16","shape":[1408,2048]},
    "model.layers.1.mlp.experts.0.up_proj.weight": {"dtype":"BF16","shape":[1408,2048]},
    "model.layers.1.mlp.experts.0.down_proj.weight": {"dtype":"BF16","shape":[2048,1408]},
    "model.layers.1.mlp.experts.1.gate_proj.weight": {"dtype":"BF16","shape":[1408,2048]},
    "model.layers.1.mlp.experts.1.up_proj.weight": {"dtype":"BF16","shape":[1408,2048]},
    "model.layers.1.mlp.experts.1.down_proj.weight": {"dtype":"BF16","shape":[2048,1408]},
     ...
    "model.layers.1.mlp.experts.63.gate_proj.weight": {"dtype":"BF16","shape":[1408,2048]},
    "model.layers.1.mlp.experts.63.up_proj.weight": {"dtype":"BF16","shape":[1408,2048]},
    "model.layers.1.mlp.experts.63.down_proj.weight": {"dtype":"BF16","shape":[2048,1408]},
    "model.layers.1.input_layernorm.weight": {"dtype":"BF16","shape":[2048]},
    "model.layers.1.post_attention_layernorm.weight": {"dtype":"BF16","shape":[2048]},
    ...
    "model.layers.26.mlp.shared_experts.gate_proj.weight": {"dtype":"BF16","shape":[2816,2048]},
    "model.layers.26.mlp.shared_experts.up_proj.weight": {"dtype":"BF16","shape":[2816,2048]},
    "model.layers.26.mlp.shared_experts.down_proj.weight": {"dtype":"BF16","shape":[2048,2816]},
    ...
    "model.layers.26.mlp.experts.63.gate_proj.weight": {"dtype":"BF16","shape":[1408,2048]},
    "model.layers.26.mlp.experts.63.up_proj.weight": {"dtype":"BF16","shape":[1408,2048]},
    "model.layers.26.mlp.experts.63.down_proj.weight": {"dtype":"BF16","shape":[2048,1408]},

```

---


# DeepSeek-V3

## Abstract

DeepSeek-V3是混合专家（MoE）语言模型，总参数量6710亿，其中每个token激活参数量为370亿。为实现高效推理与经济训练，DeepSeek-V3沿用了在DeepSeek-V2中经过充分验证的多头潜在注意力（MLA Multi-head Latent Attention）架构与DeepSeekMoE架构，并开创性地引入无辅助损失的负载均衡策略（an auxiliary-loss-free strategy for load balancing），同时采用multi-token prediction训练目标以提升模型性能。我们基于14.8万亿高质量多源语料对DeepSeek-V3进行预训练，并通过监督微调与强化学习阶段充分释放其能力。综合评估表明，DeepSeek-V3不仅显著超越其他开源模型，性能更可媲美顶尖闭源模型。该模型的完整训练仅需278.8万H800 GPU小时，且训练过程异常稳定，全程未发生任何不可恢复的损失尖峰，也未进行任何回滚操作。
模型检查点已发布于：https://github.com/deepseek-ai/DeepSeek-V3

## 1.Introduction

近年来，大型语言模型（LLM）经历了快速迭代与进化（Anthropic, 2024；Google, 2024；OpenAI, 2024a），不断逼近通用人工智能（AGI）的边界。除闭源模型外，以DeepSeek系列（DeepSeek-AI, 2024a,b,c；Guo等，2024）、LLaMA系列（AI@Meta, 2024a,b；Touvron等，2023a,b）、Qwen系列（Qwen, 2023, 2024a,b）及Mistral系列（Jiang等，2023；Mistral, 2024）为代表的开源模型也取得显著进展，持续缩小与闭源模型的差距。为进一步突破开源模型能力边界，我们通过scale up 推出DeepSeek-V3——总参数量达6710亿的混合专家（MoE）模型，其中每个token激活参数量为370亿。

基于前瞻性视角，我们始终追求卓越性能与经济成本的平衡。因此，在架构层面，为了实现高效推理，沿用多头潜在注意力（MLA）（DeepSeek-AI, 2024c），为了高效训练，仍沿用DeepSeekMoE架构（Dai等，2024）。这两项技术经过了DeepSeek-V2验证。在此基础上，我们引入两项创新策略：首先，DeepSeek-V3 引入了一种不依赖辅助损失（auxiliary-loss-free）的负载均衡策略（Wang 等, 2024a），旨在最大程度地降低为实现负载均衡而对模型性能产生的负面影响。其次，DeepSeek-V3 采用了多 token 预测的训练目标，我们观察到这一策略有助于提升在各项评测基准上的整体表现。

通过FP8混合精度训练框架实现训练加速与显存优化。低精度训练作为高效训练的有效方案（Dettmers等，2022；Kalamkar等，2019；Narang等，2017；Peng等，2023b），其发展与硬件能力演进密切关联（Luo等，2024；Micikevicius等，2022；Rouhani等，2023a）。本研究首次在超大规模模型上验证FP8训练的有效性，通过FP8计算与存储支持实现训练速度提升与显存占用降低。

为了实现高效训练，我们支持 FP8 混合精度训练，并对训练框架进行全面优化。低精度训练已经成为提升训练效率的有力解决方案（Dettmers 等, 2022；Kalamkar 等, 2019；Narang 等, 2017；Peng 等, 2023b），其发展与硬件能力的进步密切相关（Luo 等, 2024；Micikevicius 等, 2022；Rouhani 等, 2023a）。在本研究中，我们首次在超大规模模型上引入并验证了 FP8 混合精度训练框架的有效性。通过支持 FP8 的计算与存储，我们不仅加速了训练速度，还减少了 GPU 内存的占用。在训练框架方面，我们设计了 DualPipe 算法以实现高效的流水线并行。该算法减少了pipeline bubbles，并通过计算与通信的重叠（computation-communication overlap）在训练过程中隐藏了大部分通信开销。这种方式可以保证在模型规模进一步扩张时，只要维持恒定的计算与通信比率，仍能在跨节点间使用细粒度专家fine-grained experts，并将 all-to-all 通信的开销降至近乎为零。此外，我们还开发了高效的跨节点 all-to-all 通信内核，以充分利用 InfiniBand (IB) 与 NVLink 的带宽。我们也对内存占用进行了精细化优化，使得在不依赖高成本张量并行的情况下，依然可以训练 DeepSeek-V3。通过这些努力，我们实现了高效的训练过程。

在预训练阶段，我们使用 14.8T 高质量且多样化的 token 对 DeepSeek-V3 进行训练，整个预训练过程十分稳定。期间没有出现无法恢复的损失爆增，也无需回退。接下来，我们对 DeepSeek-V3 进行了两阶段的上下文长度扩展：第一阶段将最大上下文长度扩展至 32K，第二阶段进一步扩展至 128K。随后，我们对 DeepSeek-V3 的基础模型进行后训练（post-training），包括有监督微调（SFT）和强化学习（RL），以使其更贴合人类偏好并进一步释放模型潜力。在后训练阶段，我们从 DeepSeek-R1 系列模型中蒸馏其推理能力，并在此过程中谨慎地平衡模型的准确性与生成长度。

我们在大量基准上对 DeepSeek-V3 进行了全面评估。虽然训练成本较为经济，但综合评测结果显示，DeepSeek-V3-Base 已成为目前最强的开源基础模型，尤其在代码与数学方面表现突出。其聊天版本在多项标准和开放式基准上也优于其他开源模型，并在性能上可比肩主流闭源模型（包括 GPT-4o 和 Claude-3.5-Sonnet）。

最后，我们再次强调 DeepSeek-V3 所具有的经济训练成本（见表 1），这是通过算法、框架与硬件的协同优化共同实现的。在预训练阶段，DeepSeek-V3 每训练 1 万亿个 token 仅需消耗 18 万个 H800 GPU 小时；换言之，在拥有 2048 张 H800 GPU 的集群上只需运行 3.7 天即可完成。这使得整个预训练阶段在不到两个月的时间内完成，耗费了共 266.4 万 GPU 小时。再加上上下文长度扩展所用的 11.9 万 GPU 小时以及后训练所需的 0.5 万 GPU 小时，DeepSeek-V3 的完整训练总耗时仅为约 278.8 万 GPU 小时。若按每 GPU 小时 2 美元的租用价格计算，总训练成本仅为 557.6 万美元。需要注意的是，上述成本仅包括 DeepSeek-V3 的正式训练，不包含在模型架构、算法或数据等方面进行前期研究和消融实验的费用。

核心创新贡献如下：

**Architecture: Innovative Load Balancing Strategy and Training Objective**

 - 在 DeepSeek-V2 高效架构的基础上，我们率先提出了一种不依赖辅助损失的负载均衡策略，最大限度地减少了为实现负载均衡而导致的模型性能损失。

 - 我们探索了Multi-Token Prediction（MTP）目标，并证明它可以提高模型性能。同时，该目标也可用于推理加速中的推测解码（speculative decoding）。

**Pre-Training: Towards Ultimate Training Efficiency**

 - 我们设计了一套 FP8 混合精度训练框架，并首次在超大规模模型上验证了 FP8 训练的可行性与有效性。

 - 通过算法、框架与硬件的协同设计，我们突破了跨节点 MoE 训练中的通信瓶颈，实现了几乎完全的计算与通信重叠。此举不仅大幅提升了训练效率并降低了训练成本，也使得我们可以在不增加额外开销的情况下进一步扩大模型规模。

 - 仅用 266.4 万个 H800 GPU 小时的经济成本，我们完成了 DeepSeek-V3 在 14.8 万亿条文本上的预训练，打造了目前最强的开源基础模型。随后的后续训练阶段仅需 10 万个 GPU 小时。

**Post-Training: Knowledge Distillation from DeepSeek-R1**

 - 我们提出了一种创新方法，将CoT模型（Chain-of-Thought,DeepSeek-R1 系列模型之一）中的推理能力蒸馏到标准大语言模型中，尤其是 DeepSeek-V3。该流程将 R1 模型的验证与反思模式优雅地融合至 DeepSeek-V3，显著提升了其推理性能。同时，我们也对 DeepSeek-V3 的输出风格与长度加以控制。

**核心评测结果概览**

 - 知识：在 MMLU、MMLU-Pro 与 GPQA 等教育类基准上，DeepSeek-V3 超越了所有其他开源模型，分别取得了 88.5、75.9 和 59.1 的成绩，其表现可与 GPT-4o 和 Claude-Sonnet-3.5 等领先闭源模型相媲美，进一步缩小了开源与闭源模型在此领域的差距。
在客观事实相关基准上，DeepSeek-V3 在 SimpleQA 与 Chinese SimpleQA 两个数据集中均优于其他开源模型。尽管在英文事实类知识（SimpleQA）方面仍略逊于 GPT-4o 与 Claude-Sonnet-3.5，但在中文事实类知识（Chinese SimpleQA）上却超过了这些模型，展现出其在中文事实类知识方面的优势。

 - 代码、数学与推理：在数学相关基准上，DeepSeek-V3 在所有non-long-CoT的开源与闭源模型中取得了最先进的表现。值得注意的是，针对部分基准（如 MATH-500），其表现甚至超过了 o1-preview，展现了强大的数学推理能力。在编程相关任务上，DeepSeek-V3 在编程竞赛基准（如 LiveCodeBench）中取得最佳表现，牢牢占据该领域的领先地位。对于工程类任务，虽然 DeepSeek-V3 略低于 Claude-Sonnet-3.5，但依然远超其他所有模型，体现了其在多样化技术基准上的竞争力。

在后续的内容中，我们将首先详细介绍 DeepSeek-V3 的模型架构（第 2 节），包括高效推理所用的 Multi-head Latent Attention (MLA)（DeepSeek-AI, 2024c）以及经济训练所用的 DeepSeekMoE（Dai 等, 2024）等。随后，我们介绍所使用的基础设施，包括计算集群、训练框架、对 FP8 训练的支持、推理部署策略及未来硬件设计建议。接着，我们阐述预训练流程，包括训练数据的构建、超参数设置、长上下文扩展技术及相关评测与讨论（第 4 节）。然后，我们讨论后训练工作，包括有监督微调（SFT）、强化学习（RL）以及相应的评测与讨论（第 5 节）。最后，我们总结本项研究的结论，探讨 DeepSeek-V3 目前存在的限制并展望未来可能的研究方向（第 6 节）。


## 2.Architecture

我们首先介绍 DeepSeek-V3 的基本架构，其中采用了 Multi-head Latent Attention (MLA)（DeepSeek-AI, 2024c）来实现高效推理，并使用 DeepSeekMoE（Dai 等, 2024）来降低训练成本。随后，我们将介绍多 Token 预测（MTP）训练目标，该目标在评测基准上能够提升模型整体性能。除非另有说明，DeepSeek-V3 的其他细节均与 DeepSeek-V2（DeepSeek-AI, 2024c）中的设置保持一致。

### 2.1 基本架构

DeepSeek-V3 的整体框架仍然基于 Transformer（Vaswani 等, 2017）。为了实现高效推理与经济可控的训练成本，DeepSeek-V3 继续沿用 MLA 和 DeepSeekMoE，这两种方法在 DeepSeek-V2 中已得到充分验证。与 DeepSeek-V2 相比，主要的区别在于，我们在 DeepSeekMoE 中额外引入了一种无辅助损失（auxiliary-loss-free）的负载均衡策略（Wang 等, 2024a），以减轻因实现负载均衡而导致的性能下降。

#### 2.1.1 Multi-Head Latent Attention

见前文V2。

#### 2.1.2. DeepSeekMoE with Auxiliary-Loss-Free Load Balancing

回顾前文DeepSeekMoE，关键计算公式如下：

$$
\mathbf{h}_t^{'} = \mathbf{u}_t + \sum_{i=1}^{N_s} \text{FFN}_i^{(s)(\mathbf{u}_t) + \sum_{i=1}^{N_r} g_{i,t} \text{FFN}_i^{(r)}(\mathbf{u}_t)  \tag{12}
$$

$$
g_{i,t} = \frac{g'_{i,t}}{ \sum_{j=1}^{N_r}g'_{j,t}} \tag{13}
$$

$$
g'_{i,t} = 
\begin{cases} 
s_{i,t}, & s_{i,t} \in \text{Topk}(\{s_{j,t} | 1 \leq j \leq N_r \}, K_r) \\
0, & \text{otherwise}
\end{cases}  \tag{14}
$$

$$
s_{i,t} = \text{Softmax}(\mathbf{u}_t \mathbf{e}_i)  \tag{15}
$$

公式中， $\mathbf{u}_t$ 为第 t 个token的FFN输入，我们计算FFN输出 $\mathbf{h}'_t$ 如下：

其中，N_s 和N_r分别表示共享专家和路由专家的数量；K_r表示激活的路由专家数量。与DeepSeek-V2略有不同，DeepSeek-V3使用sigmoid函数来计算亲和度得分，并在所有选定的亲和度得分之间应用归一化以生成门控值。

**Auxiliary-Loss-Free Load Balancing**  

对于MoE模型，不均衡的专家负载会导致路由崩溃（Shazeer等，2017），并在专家并行场景中降低计算效率。传统的解决方案通常依赖辅助损失（Fedus等，2021；Lepikhin等，2021）来避免负载不均衡。然而，过大的辅助损失会损害模型性能（Wang等，2024a）。为了在负载均衡和模型性能之间实现更好的折衷，我们开创了一种无辅助损失的负载均衡策略（Wang等，2024a）来确保负载均衡。具体而言，我们为每个专家引入一个偏置项 $b_i$ ，并将其添加到对应的亲和度得分 $s_{i,t}$ 中，以确定top-K路由：

$$
g'_{i,t} = 
\begin{cases} 
s_{i,t}, & s_{i,t} + b_i \in \text{Topk}(\{s_{j,t}+ b_i | 1 \leq j \leq N_r \}, K_r) \\
0, & \text{otherwise}
\end{cases}  \tag{16}
$$

注意，偏置项仅用于路由。门控值、乘以FFN输出的值，仍然来自原始亲和度得分 $s_{i,t}$ 。在训练过程中，我们不断监控每个训练步骤中全批量的专家负载。在每个步骤结束时，如果对应的专家负载过重，我们会偏置项-𝛾，如果负载过轻，则偏置项+𝛾，𝛾是一个超参数，称为偏置更新速度。通过动态调整，DeepSeek-V3在训练过程中保持负载均衡，且比通过纯辅助损失来鼓励负载均衡的模型表现更好。

![图1](http://jinluzhang.github.io/assets/posts_img/2025-01-29-DeepSeek/deepseek-v3-1.png)


**Complementary Sequence-Wise Auxiliary Loss.**  

尽管DeepSeek-V3主要依赖于无辅助损失的负载均衡策略来确保负载平衡，为了防止任何单一序列内出现极端的不平衡，我们还使用了互补的序列级负载均衡损失，鼓励每个序列上，各个专家的负载也能保持均衡。

**Node-Limited Routing**  

与DeepSeek-V2使用的设备限制路由类似，DeepSeek-V3也采用了受限路由机制，在训练过程中限制通信成本。简而言之，我们确保每个token最多被发送到 M 个节点，这些节点是根据分配到每个节点上的专家的最高 $K_r$ 个亲和度得分的总和来选择的。在这个 M 限制下，我们的MoE训练框架几乎可以实现计算与通信的完全重叠。

**No Token-Dropping**

由于有效的负载均衡策略，DeepSeek-V3在整个训练过程中保持了良好的负载均衡。因此，DeepSeek-V3在训练过程中不丢弃任何tokens。此外，我们还实施了特定的部署策略，以确保推理时的负载均衡，因此DeepSeek-V3在推理过程中也不会丢弃tokens。

### 2.2. Multi-Token Prediction

#### 2.2.0 Gloeckle版本的MTP

大型语言模型，如GPT和Llama，通常损失函数是预测下一个token。MTP的方法是，把传统的预测1个改成了预测n个，输出头是n个独立的，他们在共享的模型主干上操作。认为这个预测任务更难，能让样本效率sample efficiency变高。

训练的时候，比如一个sequence的长度是T，仍旧会构建T-1个训练语料，传统的语料是：

用t1预测t2、

用t1,t2预测t3、

用t1,t2,t3预测t4、

MTP的语料是：

用t1预测t2,t3,t4,t5、

用t1,t2预测t3,t4,t5,t6、

用t1,t2,t3预测t4,t5,t6,t7、


标准语言建模通过实现下一个token预测任务来学习大规模文本语料库 $x_1, \dots, x_T$。 形式上，目标是最小化交叉熵损失：

$$
L_1 = - \sum_t \log P_\theta(x_{t+1} | x_{t:1})  
$$

MTP通过实现多token预测任务来对上述任务进行推广，在训练语料库的每个位置，模型被指示一次性预测 n 个未来的token。这转化为以下交叉熵损失：

$$
L_n = - \sum_t \log P_\theta(x_{t+n:t+1} | x_{t:1})  
$$

为了使问题易于处理，我们假设我们的语言模型 $P_\theta$ 使用共享的主干（trunk）来生成输入的上下文 $x_{t:1}$  的潜在表示 $z_{t:1}$ ，然后将其输入到 n 个独立的输出头中，并并行预测这 n 个未来token。多token预测交叉熵损失的如下因式分解：

$$
L_n = - \sum_t \log P_\theta(x_{t+n:t+1} | z_{t:1}) \cdot P_\theta(z_{t:1} | x_{t:1}) \\
 = - \sum_t \sum_{i=1}^{n} \log P_\theta(x_{t+i} | z_{t:1}) \cdot P_\theta(z_{t:1} | x_{t:1})
$$

n个独立的输出头中，每个输出头都实现为Transformer layers，并共享unembedding矩阵。

![图1](http://jinluzhang.github.io/assets/posts_img/2025-01-29-DeepSeek/deepseek-v3-3.png)


#### 2.2.1 DeepSeek版本的MTP

受到Gloeckle等（2024）的启发，我们研究并为DeepSeek-V3设定了多token预测（MTP）目标，该目标将每个位置的预测范围扩展到多个token。一方面，MTP目标使训练信号更加密集，可能提高数据效率；另一方面，MTP可以使模型预先规划其表示，以更好地预测未来的token。下图展示了我们实现MTP的方式。与Gloeckle等（2024）通过独立的输出头并行预测D个额外token不同，我们顺序地预测额外的token，并保持每个预测深度的完整因果链。在本节中，我们将介绍我们的MTP实现细节。

![图1](http://jinluzhang.github.io/assets/posts_img/2025-01-29-DeepSeek/deepseek-v3-2.png)

具体来说，我们的MTP实现使用 D 个sequential modules来预测 D 个additional tokens。第 k 个MTP模块由一个共享的嵌入层Emb(·)（它和主模型也是共享的，就这么一个embedding layer）、一个共享的输出头OutHead(·)（它和主模型也是共享的）、一个Transformer块 $TRM_k(·)$ 和一个投影矩阵 $M_k \in \mathbb{R}^{d \times 2d}$ 组成。

对于第 𝑖 个输入token $t_i$ ，它在第 𝑘 个预测depth时，我们将它在第 𝑘-1 depth的表征表示为 $h_i^{k-1} \in \mathbb{R}^d$ ，将第 𝑖+𝑘 个token的embedding表示为 $Emb(t_{i+k}) \in \mathbb{R}^d$ 。通过线性投影结合：

$$
h_i^{'k} = M_k [\text{RMSNorm}(h_i^{k-1}); \text{RMSNorm}(Emb(t_{i+k}))], \tag{21}
$$

以图中为例，看i=4第4个token，它在k=2即图中MTP Module 2中的处理过程。此处 $h_i^{k-1}$ 是第4个token在MTP Module 1的Transformer Blocker处理后的对应输出，是一个潜在表征形式；MTP Module 2针对第4个token应该输出它后面的第三个预测token，i+k=6是它在MTP Module 1中对应的预测输出token。

然后送入Transformer块输出当前depth的representation：

$$
h_{1:T-k}^k = TRM(h_{1:T-k}^{'k}), \tag{22}
$$

然后输入到输出头中得到预测结果：

$$
p_{i+k+1}^k = \text{OutHead}(h_i^k), \tag{23}
$$

输出头OutHead(·)将表示线性映射到logits，并随后应用Softmax(·)函数来计算第 k 个额外token的预测概率。我们保持预测的因果链的原则类似于EAGLE（Li等，2024b），但EAGLE的主要目标是speculative decoding（Leviathan等，2023；Xia等，2023），而我们则是用MTP来改进训练。

**MTP Training Objective**

对于每个预测depth k，我们计算交叉熵损失 $L_k^{MTP}$：

$$
\mathcal{L}_k^{MTP} = \text{CrossEntropy}(P_{2+k:T+1}^k, t_{2+k:T+1}) = - \frac{1}{T} \sum_{i=2+k}^{T+1} \log P_i^k[t_i], \tag{24}
$$

其中，T 表示输入序列长度，t_i 表示第 i 位置的真实token，$P_i^k[t_i]$ 表示第 k 个MTP模块给出的对应预测概率。最后，我们计算所有深度的MTP损失的平均值，并乘以一个加权因子 $\lambda$  来获得整体MTP损失 ，作为DeepSeek-V3的额外训练目标：

$$
\mathcal{L}_{MTP} = \frac{\lambda}{D} \sum_{k=1}^{D} \mathcal{L}_{MTP}^k \tag{25}
$$

**MTP in Inference.**  

我们的MTP策略主要旨在提升主模型的性能，因此在推理过程中，我们可以直接丢弃MTP模块，主模型可以独立且正常地运行。此外，我们还可以将这些MTP模块重新用于speculative decoding，以进一步提高生成延迟。


## 3. Infrastructures

### 3.1. Compute Clusters

DeepSeek-V3在配备2048个NVIDIA H800 GPU的集群上进行训练。H800集群中的每个节点包含8个GPU，通过NVLink和NVSwitch在节点内部进行连接。在不同节点之间，使用InfiniBand (IB)互连来促进通信。

### 3.2. Training Framework

DeepSeek-V3的训练由HAI-LLM框架支持，这是我们工程师从零开始设计的一个高效轻量级训练框架。总体而言，DeepSeek-V3应用了16路管道并行（PP）（Qi等，2023a），跨8个节点的64路专家并行（EP）（Lepikhin等，2021），ZeRO-1数据并行（DP）（Rajbhandari等，2020）。

为了促进DeepSeek-V3的高效训练，我们实施了精细的工程优化。首先，我们设计了DualPipe算法以提高管道并行效率。与现有的PP方法相比，DualPipe减少了管道气泡。更重要的是，它通过有效重叠前向和反向计算-通信阶段，解决了由跨节点专家并行引入的重通信开销问题。其次，我们开发了高效的跨节点all-to-all通信内核，以充分利用IB和NVLink带宽，并节省用于通信的流处理单元（SM）。最后，我们精细优化了训练过程中的内存占用，从而使我们能够在不使用昂贵的张量并行（TP）的情况下训练DeepSeek-V3。

#### 3.2.1. DualPipe and Computation-Communication Overlap

对于DeepSeek-V3，由跨节点专家并行引入的通信开销导致计算与通信的比率大约为1:1。为了解决这一挑战，我们设计了一个创新的管道并行算法——DualPipe，它不仅通过有效地重叠前向和反向计算-通信阶段来加速模型训练，还减少了管道气泡。

DualPipe的关键思想是在一个前向+反向chunks里，overlap计算与通信。具体来说，我们将每个块分为四个部分：注意力、all-to-all分发、MLP、all-to-all合并。特别地，对于反向块，注意力和MLP还进一步分为输入反向和权重反向两部分，类似于ZeroBubble（Qi等，2023b）。此外，我们还设计了一个PP通信组件。如图4所示，对于一对前向和反向块，我们重新排列这些组件，并手动调整用于通信和计算的GPU SM比例。在这种重叠策略中，我们可以确保全到全和PP通信在执行过程中能够完全隐藏。鉴于这一高效的重叠策略，完整的DualPipe调度如图5所示。它采用了双向管道调度，同时从管道的两端输入微批次，并且大部分通信可以完全重叠。这种重叠还确保了，随着模型的进一步扩展，只要我们保持恒定的计算与通信比率，就可以在跨节点使用精细化的专家，同时实现接近零的all-to-all通信开销。

![图4](http://jinluzhang.github.io/assets/posts_img/2025-01-29-DeepSeek/deepseek-v3-4.png)

![图5](http://jinluzhang.github.io/assets/posts_img/2025-01-29-DeepSeek/deepseek-v3-4.png)

此外，即使在没有重通信负担的更一般场景下，DualPipe仍然表现出效率优势。在表2中，我们总结了不同PP方法的管道气泡和内存使用情况。与ZB1P（Qi等，2023b）和1F1B（Harlap等，2018）相比，DualPipe显著减少了管道气泡，同时仅将峰值激活内存增加了1倍。尽管DualPipe需要保持模型参数的两个副本，但由于我们在训练过程中使用较大的EP大小，这不会显著增加内存消耗。与Chimera（Li和Hoefler，2021）相比，DualPipe只要求管道阶段和微批次能够被2整除，而不要求微批次必须被管道阶段整除。此外，对于DualPipe，随着微批次数量的增加，管道气泡或激活内存不会增加。

#### 3.2.2. Efficient Implementation of Cross-Node All-to-All Communication

为了确保DualPipe的计算性能，我们定制了高效的跨节点全到全通信内核（包括分发和合并），以节省用于通信的SM数量。这些内核的实现与MoE门控算法以及我们集群的网络拓扑共同设计。具体而言，在我们的集群中，跨节点GPU通过IB完全互连，节点内通信则通过NVLink处理。NVLink提供160GB/s的带宽，约为IB（50GB/s）的3.2倍。为了有效利用IB和NVLink的不同带宽，我们限制每个token最多被分发到4个节点，从而减少IB流量。对于每个token，当做出路由决策时，它将首先通过IB传输到目标节点上具有相同节点索引的GPU。一旦到达目标节点，我们将尽力确保它通过NVLink瞬时转发到承载目标专家的特定GPU，而不会被后续到达的token阻塞。通过这种方式，IB和NVLink之间的通信被完全重叠，每个token可以高效地选择每个节点上的平均3.2个专家，而不会增加来自NVLink的额外开销。这意味着，尽管DeepSeek-V3 在实践中只选择8个路由专家，但它可以将这个数量扩展到最多13个专家（4个节点×3.2专家/节点），同时保持相同的通信成本。总体而言，在这种通信策略下，只有20个SM足以充分利用IB和NVLink的带宽。

具体而言，我们采用了warp专用技术（Bauer等，2014）并将20个SM划分为10个通信通道。在分发过程中，(1) IB发送，(2) IB到NVLink的转发，以及(3) NVLink接收由各自的warp处理。 分配给每个通信任务的warp数量会根据所有SM的实际工作负载动态调整。类似地，在合并过程中，(1) NVLink发送，(2) NVLink到IB的转发与积累，(3) IB接收与积累也由动态调整的warp处理。 此外，分发和合并内核与计算流重叠，因此我们还考虑它们对其他SM计算内核的影响。具体来说，我们采用定制的PTX（并行线程执行）指令，并自动调整通信块大小，从而显著减少L2缓存的使用以及对其他SM的干扰。

#### 3.2.3. Extremely Memory Saving with Minimal Overhead

为了减少训练过程中的内存占用，我们采用了以下技术。

**RMSNorm和MLA Up-Projection的重新计算**  
我们在反向传播过程中重新计算所有RMSNorm操作和MLA向上投影，从而消除了持续存储它们输出激活值的需要。通过较小的开销，这种策略显著减少了存储激活值所需的内存。

**CPU中的指数移动平均（EMA）**  
在训练过程中，我们保留模型参数的指数移动平均（EMA，Exponential Moving Average），以便在学习率衰减后进行早期的模型性能估计。EMA参数存储在CPU内存中，并在每个训练步骤后异步更新。这种方法允许我们在不增加额外内存或时间开销的情况下维护EMA参数。

**多token预测的共享嵌入和输出头**  
采用DualPipe策略时，我们将模型的最浅层（包括嵌入层）和最深层（包括输出头）部署在同一PP rank上。这种安排使得共享嵌入和输出头的参数与梯度能够在MTP模块和主模型之间物理共享。这种物理共享机制进一步提高了我们的内存效率。

### 3.3. FP8 Training

受到近期低精度训练的进展启发（Dettmers等，2022；Noune等，2022；Peng等，2023b），我们提出了一个精细的混合精度框架，利用FP8数据格式来训练DeepSeek-V3。尽管低精度训练具有巨大的潜力，但它常常受到激活值、权重和梯度中的异常值的限制（Fishman等，2024；He等；Sun等，2024）。尽管在推理量化方面取得了显著进展（Frantar等，2022；Xiao等，2023），但在大规模语言模型预训练中成功应用低精度技术的研究相对较少（Fishman等，2024）。为了解决这个挑战并有效扩展FP8格式的动态范围，我们引入了一种精细的量化策略：按 1×N_c 元素的tile方式分组或按 N_c×N_c 元素的块方式分组。通过我们增加精度的累积过程，相关的去量化开销大大减少，这对于实现准确的FP8通用矩阵乘法（GEMM）至关重要。此外，为了进一步减少MoE训练中的内存和通信开销，我们将激活值缓存并调度为FP8，同时将低精度优化器状态存储为BF16。我们在两个与DeepSeek-V2-Lite和DeepSeek-V2相似的模型规模上验证了提出的FP8混合精度框架，训练了大约1万亿个token。值得注意的是，与BF16基准相比，我们的FP8训练模型的相对损失误差始终保持在0.25%以下，这个误差水平完全在训练随机性可接受的范围内。

#### 3.3.1. Mixed Precision Framework

基于低精度训练中广泛采用的技术（Kalamkar等，2019；Narang等，2017），我们提出了一个用于FP8训练的混合精度框架。在该框架中，大多数计算密集型操作都在FP8精度下进行，而少数关键操作则在原始数据格式中保持，以平衡训练效率和数值稳定性。整体框架如图6所示。

![图6](http://jinluzhang.github.io/assets/posts_img/2025-01-29-DeepSeek/deepseek-v3-6.png)

首先，为了加速模型训练，大多数核心计算内核，如GEMM操作，都以FP8精度实现。这些GEMM操作接受FP8张量作为输入，并产生BF16或FP32格式的输出。如图6所示，与线性操作相关的所有三个GEMM，即Fprop（forward pass）、Dgrad（activation backward pass）和Wgrad（weight backward pass），都以FP8执行。这一设计理论上使得计算速度比原始BF16方法提高一倍。此外，FP8的Wgrad GEMM允许激活值以FP8存储，以便用于反向传播。这显著减少了内存消耗。

尽管FP8格式在效率上具有优势，但某些操作由于对低精度计算的敏感性仍需要更高的精度。此外，一些低成本操作也可以利用更高的精度，而对整体训练成本的影响微乎其微。因此，经过仔细调查后，我们为以下组件保持原始精度（如BF16或FP32）：嵌入模块、输出头、MoE门控模块、归一化操作和注意力操作。这些有针对性的高精度保留确保了DeepSeek-V3的稳定训练动态。为了进一步保证数值稳定性，我们将主权重、权重梯度和优化器状态存储为更高精度。尽管这些高精度组件会产生一些内存开销，但通过在分布式训练系统中跨多个DP rank进行高效分片，它们的影响可以最小化。

#### 3.3.2. Improved Precision from Quantization and Multiplication

基于我们的混合精度FP8框架，我们提出了几种策略来提高低精度训练的准确性，重点关注量化方法和乘法过程。

**Fine-Grained Quantization**  

在低精度训练框架中，由于FP8格式的动态范围有限，通常会遇到溢出和下溢的问题，这主要是由于其减少的指数位数。作为标准做法，输入分布通过将输入张量的最大绝对值缩放到FP8可表示的最大值来对齐FP8格式的表示范围（Narang等，2017）。这种方法使低精度训练对激活值异常值非常敏感，这可能严重降低量化的准确性。为了解决这个问题，我们提出了一种精细的量化方法，在更细粒度的层次上应用缩放。如图7（a）所示，(1) 对于激活值，我们在1x128的tile基础上进行分组和缩放（即每个token每128个通道）；(2) 对于权重，我们在128x128的块基础上进行分组和缩放（即每128个输入通道每128个输出通道）。这种方法确保量化过程可以通过根据较小元素组调整缩放来更好地适应异常值。在附录B.2中，我们进一步讨论了当我们像权重量化一样按块方式对激活值进行分组和缩放时，训练不稳定性的问题。

我们方法中的一个关键修改是引入了沿GEMM操作内部维度的每组缩放因子。标准FP8 GEMM不直接支持这一功能。然而，结合我们精确的FP32累积策略，它可以高效地实现。

值得注意的是，我们的精细量化策略与microscaling formats 的思想高度一致（Rouhani等，2023b），而NVIDIA下一代GPU的Tensor Cores（Blackwell系列）已经宣布支持具有更小量化粒度的微缩格式（NVIDIA，2024a）。我们希望我们的设计能够为未来的工作提供参考，以跟上最新GPU架构的发展。

![图7](http://jinluzhang.github.io/assets/posts_img/2025-01-29-DeepSeek/deepseek-v3-7.png)

**Increasing Accumulation Precision**

低精度GEMM操作常常面临下溢问题，其精度在很大程度上依赖于高精度的累加操作，通常在FP32精度下执行（Kalamkar等，2019；Narang等，2017）。然而，我们观察到，NVIDIA H800 GPU上FP8 GEMM的累加精度仅能保留大约14位，这远低于FP32累加精度。当内维度K较大时（Wortsman等，2023），这一问题尤为突出，这是大规模模型训练中常见的场景，通常会增加批量大小和模型宽度。以K = 4096的两个随机矩阵的GEMM操作为例，在我们的初步测试中，Tensor Cores中有限的累加精度导致最大相对误差接近2%。尽管存在这些问题，有限的累加精度仍然是少数FP8框架的默认选项（NVIDIA，2024b），这严重限制了训练精度。

为了解决这一问题，我们采用了将累加操作提升到CUDA Cores以提高精度的策略（Thakkar等，2023）。该过程如图7（b）所示。具体而言，在Tensor Cores上执行MMA（矩阵乘加）操作时，使用有限的位宽对中间结果进行累加。一旦达到𝑁𝐶的区间，这些部分结果将被复制到CUDA Cores上的FP32寄存器中，在那里进行全精度的FP32累加。如前所述，我们的细粒度量化在内维度K上应用了每组的缩放因子。这些缩放因子可以在CUDA Cores上高效地与去量化过程相乘，几乎不增加额外的计算成本。

值得注意的是，这一修改减少了单个warpgroup的WGMMA（warpgroup级矩阵乘加）指令问题率。然而，在H800架构上，两个WGMMA通常会并行存在：当一个warpgroup执行提升操作时，另一个可以执行MMA操作。这种设计使得两个操作可以重叠执行，保持Tensor Cores的高利用率。根据我们的实验，设置𝑁𝐶 = 128元素，相当于4个WGMMAs，代表着一个显著提高精度而不会引入大量开销的最小累加区间。

**Mantissa over Exponents**

在与之前工作的混合FP8格式（NVIDIA，2024b；Peng等，2023b；Sun等，2019b）不同，我们采用了E4M3格式在所有张量上进行高精度处理（即Fprop使用E4M3，Dgrad和Wgrad使用E5M2）。我们将这一方法的可行性归功于我们的细粒度量化策略，即瓦片和块级缩放。通过对更小的元素组进行操作，我们的方法有效地在这些分组的元素之间共享指数位，减轻了有限动态范围的影响。

**Online Quantization**

延迟量化通常用于张量级量化框架（NVIDIA，2024b；Peng等，2023b），通过维持之前迭代中的最大绝对值历史记录来推断当前值。为了确保准确的缩放并简化框架，我们在线计算每个1x128激活瓦片或128x128权重块的最大绝对值。基于此，我们得出缩放因子，然后在线将激活或权重量化为FP8格式。

#### 3.3.3. Low-Precision Storage and Communication

结合我们的FP8训练框架，我们通过将缓存的激活值和优化器状态压缩为更低精度格式，进一步减少了内存消耗和通信开销。

**低精度优化器状态**  
我们采用BF16数据格式而非FP32来追踪AdamW（Loshchilov和Hutter，2017）优化器中的一阶和二阶矩，而不会引起可观的性能下降。然而，主权重（由优化器存储）和梯度（用于批量大小累积）仍保留在FP32中，以确保整个训练过程的数值稳定性。

**低精度激活值**  
如图6所示，Wgrad操作在FP8中执行。为了减少内存消耗，将激活值缓存为FP8格式用于线性操作的反向传播是一个自然的选择。然而，对于一些操作，我们在低成本高精度训练中特别考虑：

(1) **注意力操作后的线性输入**。这些激活值还用于注意力操作的反向传播，这使得它们对精度非常敏感。我们为这些激活值采用了定制的E5M6数据格式。此外，这些激活值将在反向传播中从1x128量化tile转换为128x1tile。为了避免引入额外的量化误差，所有的缩放因子都采用整数量化，即2的整数次方。

(2) **MoE中的SwiGLU操作输入**。为了进一步减少内存开销，我们缓存SwiGLU操作的输入，并在反向传播中重新计算其输出。这些激活值同样采用我们的精细量化方法，存储为FP8，以在内存效率和计算精度之间取得平衡。

**低精度通信**  
通信带宽是训练MoE模型时的一个关键瓶颈。为了解决这个问题，我们将MoE向上传播之前的激活量化为FP8，然后应用调度组件，这与MoE向上传播中的FP8 Fprop兼容。与线性操作后注意力操作的输入类似，这些激活的缩放因子为2的整数次方。对于反向传播中的MoE下行传播激活梯度，也采用类似策略。对于前向传播和反向传播的合并组件，我们将它们保留为BF16，以保持训练过程中关键部分的精度。

### 3.4. Inference and Deployment

我们将DeepSeek-V3部署在H800集群中，每个节点内的GPU通过NVLink互连，整个集群的所有GPU通过IB完全互连。为了同时确保在线服务的服务级别目标（SLO）和高吞吐量，我们采用以下部署策略，分离了预填充和解码阶段。

#### 3.4.1. Prefilling

预填充阶段的最小部署单元由4个节点和32个GPU组成。注意力部分采用4路张量并行（TP4）与序列并行（SP）结合，并使用8路数据并行（DP8）。其较小的TP大小为4，限制了TP通信的开销。对于MoE部分，我们使用32路专家并行（EP32），确保每个专家处理足够大的批量大小，从而提高计算效率。对于MoE全到全通信，我们使用与训练阶段相同的方法：首先通过IB在节点之间传输token，然后通过NVLink在节点内GPU之间转发。特别地，对于浅层的密集MLP，我们使用1路张量并行以节省TP通信。

为了在MoE部分实现专家之间的负载平衡，我们需要确保每个GPU处理大致相同数量的token。为此，我们引入了一种冗余专家部署策略，复制高负载专家并进行冗余部署。高负载专家通过在在线部署过程中收集的统计数据检测，并定期调整（例如，每10分钟）。确定冗余专家集后，我们将基于观察到的负载，仔细重新安排节点内GPU之间的专家部署，尽量在不增加跨节点全到全通信开销的情况下实现负载平衡。对于DeepSeek-V3的部署，我们为预填充阶段设置了32个冗余专家。对于每个GPU，除了原始的8个专家外，还会额外部署一个冗余专家。

此外，在预填充阶段，为了提高吞吐量并隐藏全到全和TP通信的开销，我们同时处理两个计算负载相似的微批次，将一个微批次的注意力和MoE与另一个微批次的调度和合并重叠。

最后，我们正在探索专家的动态冗余策略，每个GPU托管更多专家（例如16个)，但在每一步推理时只激活9个，在每层的all-to-all操作开始前，我们会实时计算全局最优的路由方案。考虑到预填充阶段涉及的巨大计算量，计算这个路由方案的开销几乎可以忽略不计。

#### 3.4.2. Decoding

在解码过程中，我们将共享专家视为路由专家。从这个角度来看，每个token在路由时会选择9个专家，其中共享专家被视为一个重负载专家，并且会始终被选中。解码阶段的最小部署单元由40个节点和320个GPU组成。注意力部分采用TP4与SP结合，并与DP80结合使用，而MoE部分使用EP320。在MoE部分，每个GPU只主办一个专家，64个GPU负责主办冗余专家和共享专家。调度和合并部分的全到全通信通过IB的直接点对点传输执行，以实现低延迟。此外，我们利用IBGDA（NVIDIA，2022）技术进一步减少延迟并提高通信效率。

与预填充阶段类似，我们根据在线服务的统计专家负载，在一定间隔内定期确定冗余专家的集合。然而，我们不需要重新安排专家，因为每个GPU只主办一个专家。我们还在探索解码的动态冗余策略，但这需要更加仔细地优化计算全局最优路由方案的算法，并与调度内核融合，以减少开销。

此外，为了提高吞吐量并隐藏全到全通信的开销，我们还在解码阶段探索同时处理两个计算负载相似的微批次。与预填充阶段不同，注意力在解码阶段消耗了更多的时间。因此，我们将一个微批次的注意力与另一个微批次的调度+MoE+合并重叠。在解码阶段，每个专家的批量大小相对较小（通常在256个token以内），瓶颈主要是内存访问，而不是计算。由于MoE部分只需要加载一个专家的参数，因此内存访问开销最小，所以使用更少的SM并不会显著影响整体性能。因此，为了避免影响注意力部分的计算速度，我们可以将只有一小部分SM分配给调度+MoE+合并部分。

### 3.5. Suggestions on Hardware Design

基于我们在全到全通信和FP8训练方案中的实现，我们向AI硬件供应商提出以下芯片设计建议。

#### 3.5.1. Communication Hardware

在DeepSeek-V3中，我们实现了计算和通信的重叠，以隐藏计算过程中的通信延迟。与串行计算和通信相比，这大大减少了对通信带宽的依赖。然而，当前的通信实现依赖于昂贵的SM（例如，我们为此目的将H800 GPU中的132个SM中的20个分配给通信任务），这将限制计算吞吐量。此外，使用SM进行通信会导致显著的低效，因为张量核心完全未被充分利用。

当前，SM主要执行以下任务：
- 在IB（InfiniBand）和NVLink域之间转发数据，同时从一个GPU聚合目标为多个GPU的IB流量。
- 在RDMA缓冲区（注册GPU内存区域）和输入/输出缓冲区之间传输数据。
- 执行用于全到全合并的减少操作。
- 管理跨IB和NVLink域的多个专家数据的精细内存布局。

我们希望未来的供应商开发硬件，将这些通信任务从宝贵的计算单元SM中卸载，以作为GPU协处理器或网络协处理器，类似于NVIDIA的SHARP（Graham等，2016）。此外，为了减少应用程序编程的复杂性，我们希望这个硬件能够从计算单元的角度统一IB（扩展）和NVLink（升级）网络。通过这个统一接口，计算单元可以通过提交基于简单原语的通信请求轻松完成跨整个IB-NVLink统一域的读写、多播和减少等操作。

#### 3.5.2. Compute Hardware

**在Tensor核心中提高FP8 GEMM累积精度**  
在NVIDIA Hopper架构的当前Tensor核心实现中，FP8 GEMM（通用矩阵乘法）采用定点累积，在加法前通过右移对齐尾数乘积。这些实验揭示，它仅使用每个尾数乘积的最高14位，右移后填充符号并截断超过该范围的位。然而，例如，为了从32次FP8×FP8乘法的累积中获得准确的FP32结果，至少需要34位的精度。因此，我们建议未来的芯片设计在Tensor核心中提高累积精度，支持全精度累积，或根据训练和推理算法的精度要求选择适当的累积位宽。这样可以确保误差保持在可接受范围内，同时保持计算效率。

**支持Tile和块级量化**  
当前GPU仅支持每张量的量化，缺乏对我们方法中Tile和块级量化的本地支持。在当前实现中，当达到\(N_C\)间隔时，部分结果将从Tensor核心复制到CUDA核心，乘以缩放因子，并加到CUDA核心的FP32寄存器中。尽管通过我们精确的FP32累积策略显著缓解了去量化开销，但Tensor核心与CUDA核心之间频繁的数据移动仍然限制了计算效率。因此，我们建议未来的芯片通过使Tensor核心能够接收缩放因子并实施具有组缩放的MMA来支持精细量化。通过这种方式，整个部分和去量化累积可以直接在Tensor核心内部完成，直到产生最终结果，从而避免频繁的数据移动。

**支持在线量化**  
尽管在线量化在我们的研究中已证明其有效性，但当前的实现仍难以有效支持在线量化。在现有过程中，我们需要从HBM（高带宽内存）读取128个BF16激活值（上一次计算的输出），然后将量化后的FP8值写回HBM，再次读取进行MMA。为了解决这个低效问题，我们建议未来的芯片将FP8转换和TMA（张量内存加速器）访问整合为一个单一的融合操作，这样量化就可以在从全局内存到共享内存的激活值传输过程中完成，避免频繁的内存读写。我们还建议支持一个warp级别的转换指令，以加速处理，这将进一步促进层归一化和FP8转换的更好融合。或者，可以采用接近内存的计算方法，将计算逻辑放置在接近HBM的位置。在这种情况下，BF16元素在从HBM读入GPU时可以直接转换为FP8，从而减少大约50%的外部内存访问。

**支持转置GEMM操作**  
当前架构使得将矩阵转置与GEMM操作融合变得复杂。在我们的工作流程中，前向传播期间的激活被量化为1x128的FP8 tiles并存储。在反向传播中，矩阵需要被读出，去量化、转置、重新量化为128x1 tiles，并存储在HBM中。为了减少内存操作，我们建议未来的芯片启用直接从共享内存读取转置矩阵的操作，然后进行MMA计算，用于训练和推理中的精度需求。结合FP8格式转换和TMA访问的融合，这项改进将显著简化量化工作流。

## 4. Pre-Training

### 4.1. Data Construction

相比于 DeepSeek-V2，我们优化了预训练语料库，提高了数学和编程样本的比例，同时扩展了除英语和中文以外的多语言覆盖范围。此外，我们改进了数据处理流水线，以最小化冗余，同时保持语料的多样性。受 Ding 等（2024）的启发，我们实现了文档打包（document packing）方法以保持数据完整性，但在训练过程中未采用跨样本注意力掩码（cross-sample attention masking）。最终，DeepSeek-V3 的训练语料包含 14.8T 高质量、多样化的 token，并使用我们自研的 tokenizer 进行标记化。  

在 DeepSeekCoder-V2（DeepSeek-AI, 2024a）的训练过程中，我们观察到 Fill-in-Middle（FIM）策略在不影响下一个 token 预测能力的同时，使模型能够基于上下文线索准确预测中间文本。因此，与 DeepSeekCoder-V2 保持一致，我们也在 DeepSeek-V3 的预训练过程中引入了 FIM 策略。具体而言，我们采用前缀-后缀-中间（Prefix-Suffix-Middle, PSM）框架来构造数据，其格式如下：  

```
<|fim_begin|> 𝑓pre <|fim_hole|> 𝑓suf <|fim_end|> 𝑓middle <|eos_token|>.
```

该结构在文档级别应用，作为数据预打包过程的一部分。FIM 策略的应用比例为 0.1，与 PSM 框架保持一致。  

DeepSeek-V3 的 tokenizer 采用基于字节级 BPE（Byte-level BPE，Shibata 等，1999），并扩展了词汇表至 128K token。我们对 pretokenizer 和 tokenizer 训练数据进行了优化，以提高多语言压缩效率。此外，与 DeepSeek-V2 相比，新版 pretokenizer 引入了包含标点符号和换行符的组合 token。然而，该方法可能在模型处理多行提示（multi-line prompts）时引入 token 边界偏差（token boundary bias, Lundberg, 2023），尤其是在 few-shot 评估提示（few-shot evaluation prompts）缺少终止换行符的情况下。为了解决此问题，我们在训练过程中随机拆分一定比例的此类组合 token，使模型能够适应更广泛的特殊情况，从而降低该偏差的影响。  

### 4.2. Hyper-Parameters

**模型超参数**

我们将 Transformer 层数设置为 61，隐藏维度设为 7168。所有可学习参数均使用标准差为 0.006 的随机初始化。在多层注意力（MLA, Multi-Level Attention）中，我们将注意力头数 𝑛h 设为 128，每个头的维度 𝑑h 设为 128。键值（KV）压缩维度 𝑑𝑐 设为 512，查询压缩维度 𝑑𝑐′ 设为 1536。对于解耦的查询和键，我们将每个头的维度 𝑑𝑅 设为 64。  

除了前三层 FFN（前馈神经网络）外，其余层均使用 MoE（混合专家）层替换。每个 MoE 层由 1 个共享专家和 256 个路由专家组成，每个专家的中间隐藏维度设为 2048。在路由专家中，每个 token 将激活 8 个专家，并且保证每个 token 最多被发送到 4 个节点。  

多 token 预测深度 𝐷 设为 1，即每个 token 除了精确预测下一个 token 外，还会额外预测一个 token。与 DeepSeek-V2 一样，DeepSeek-V3 在压缩的潜在向量之后也采用了额外的 RMSNorm 层，并在宽度瓶颈处乘以额外的缩放因子。在此配置下，DeepSeek-V3 总参数量达到 **671B**，其中每个 token 仅激活 **37B** 参数。  

**训练超参数**

我们采用 AdamW 优化器（Loshchilov 和 Hutter, 2017），其超参数设置为 𝛽1 = 0.9，𝛽2 = 0.95，weight_decay = 0.1。预训练期间的 最大序列长度设为 4K，总训练 token 数为 14.8T。  

在学习率调度方面，首先在前 2K 步内线性增长，从 0 增长到 2.2 × 10⁻⁴。然后，在模型消耗 10T 训练 token之前，学习率保持为常数 2.2 × 10⁻⁴。接着，在 4.3T token 内逐步衰减至 2.2 × 10⁻⁵，遵循余弦衰减曲线cosine decay curve。在最后500B token 训练期间，前 333B token学习率保持 2.2 × 10⁻⁵ ，然后在剩余 167B token 内切换到 7.3 × 10⁻⁶。  

### 4.3 Long Context Extension

我们采用了与 DeepSeek-V2（DeepSeek-AI, 2024c 类似的方法，使 DeepSeek-V3 具备长上下文能力。在预训练阶段完成后，我们使用 YaRN（Peng et al., 2023a）进行上下文扩展，并执行两个额外的训练阶段，每个阶段包含 1000 步，逐步将上下文窗口从 4K 扩展至 32K，然后进一步扩展至 128K。  

YaRN 的配置与 DeepSeek-V2 保持一致，仅应用于解耦的共享键 $k_t^R$ 。超参数在两个阶段中保持不变，具体设置如下：
缩放参数 𝑠 = 40 ，α = 1，β = 32，缩放因子 𝑡 = 0.1 ln(𝑠) + 1 。 

## 5. Post-Training

### 5.1. Supervised Fine-Tuning

我们精心构建了指令微调（instruction-tuning）数据集，包括 150 万个跨多个领域的实例，每个领域采用针对其特定需求定制的数据创建方法。

**推理数据（Reasoning Data）**

对于数学、编程竞赛问题和逻辑谜题等推理相关数据集，我们利用内部 DeepSeek-R1 模型生成数据。尽管 R1 生成的数据在准确性方面表现出色，但仍存在思维过度（overthinking）、格式混乱（poor formatting）、内容冗长（excessive length）等问题。我们的目标是在 R1 生成数据的高准确性与格式规范、简明扼要的推理数据之间取得平衡。

为建立我们的方法论，我们首先针对特定领域（如代码、数学或通用推理）开发一个专家模型（expert model），并使用监督微调（SFT）+ 强化学习（RL）训练流水线进行优化。该专家模型充当最终模型的数据生成器。在训练过程中，我们针对每个实例生成两种不同的 SFT 样本：第一个形式为 \<problem, original response\> ，包含问题及其原始回答；第二个形式为 \<system prompt, problem, R1 response\> 。其中系统提示包含了精心设计的instructions，以引导模型生成具有反思（reflection）和验证（verification）机制的回答。

在强化学习（RL）阶段，模型使用高温采样（high-temperature sampling），以整合 R1 生成数据和原始数据的模式，即便没有明确的系统提示，模型仍能学习这些特性。经过数百步强化学习后，中间 RL 模型逐步掌握 R1 模式，从而策略性地提高整体性能。

在 RL 训练完成后，我们使用拒绝采样（rejection sampling）来筛选高质量 SFT 数据作为最终模型的训练数据，并使用专家模型作为数据生成源。这种方法确保最终训练数据既保留了 DeepSeek-R1 的优势，又能够生成简洁、有效的回答。

**非推理数据（Non-Reasoning Data）**

对于非推理数据（如创意写作、角色扮演、简单问答等），我们使用 DeepSeek-V2.5 生成回答，并聘请人工标注员对数据的准确性和正确性进行核验。

**SFT 训练设置（SFT Settings）**

我们使用 DeepSeek-V3-Base 进行两轮（epochs）监督微调，并采用余弦衰减学习率调度（cosine decay learning rate scheduling），学习率从 5 × 10⁻⁶ 逐渐衰减到 1 × 10⁻⁶。在训练过程中，每个单一序列是由多个样本拼接而成，但我们采用样本屏蔽策略（sample masking strategy），确保这些样本保持独立，不会相互影响。


### 5.2. 强化学习（Reinforcement Learning）

#### 5.2.1. 奖励模型（Reward Model）

我们在强化学习过程中采用基于规则的奖励模型（Rule-Based RM）和基于模型的奖励模型（Model-Based RM）。

**基于规则的奖励模型（Rule-Based RM）**

对于可以通过特定规则验证的问题，我们使用基于规则的奖励系统来提供反馈。例如：对于某些数学问题，答案是确定的，因此我们要求模型在指定格式（如框内显示最终答案）中给出答案，以便通过规则进行验证。对于 LeetCode 编程题，我们可以使用编译器运行测试用例，并基于测试结果生成反馈。

通过尽可能使用基于规则的验证方式，我们提高了奖励系统的可靠性，因为这种方法不易被操纵或利用。

**基于模型的奖励模型（Model-Based RM）**

对于具有free-form ground-truth的问题，我们依赖奖励模型（Reward Model）来评估回答是否符合预期的ground-truth。若问题没有明确的ground-truth（如创意写作类任务），奖励模型会基于问题和回答提供评分。该奖励模型是基于 DeepSeek-V3 SFT 检查点进行训练的。为了增强其可靠性，我们构建了偏好数据（preference data），不仅提供最终奖励值，还包含思维链路（chain-of-thought），即评分依据。这种方法有助于降低特定任务中奖励欺骗（reward hacking）的风险。


#### 5.2.2. Group Relative Policy Optimization

见V2内容。


### 5.4. Discussion

#### 5.4.1. Distillation from DeepSeek-R1

我们基于 DeepSeek-V2.5 进行实验，分析来自 DeepSeek-R1 蒸馏的贡献。baseline模型使用短CoT数据做训练，
待评估的模型则使用由上述expert checkpoints生成的数据，即使用了R1蒸馏数据。

表 9 证明了蒸馏数据的有效性，在 LiveCodeBench 和 MATH-500基准测试上均取得了显著提升。然而，我们的实验揭示了一个有趣的权衡：蒸馏可以提高模型性能，但同时显著增加平均回答长度。为了在 模型准确性 和 计算效率 之间取得平衡，我们在 DeepSeek-V3 训练中精心选择了最佳的蒸馏配置。

我们的研究表明，来自推理模型的知识蒸馏 为后训练优化提供了有前景的方向。尽管我们当前的研究主要集中在数学和编程领域的数据蒸馏，但这种方法在更广泛的任务领域中也具有潜力。我们在这些特定领域的实验表明，长 CoT（long-CoT）蒸馏 可能对其他需要复杂推理的认知任务有所帮助，因此未来在不同领域深入探索此方法仍是重要的研究方向。

#### 5.4.2. Self-Rewarding

奖励机制在强化学习（RL）中至关重要，它直接引导优化过程。在某些场景（如数学和编程），可以通过外部工具验证答案的正确性，因此 RL 在这些任务中的效果极佳。然而，在更广泛的场景下，通过硬编码构建反馈机制是不现实的。

在 DeepSeek-V3 的开发过程中，我们针对这些更广泛的场景采用了Constitutional AI方法（Bai et al., 2022），利用 DeepSeek-V3 自身的投票评估结果 作为反馈源。这种方法在对齐方面取得了显著成效，极大提升了 DeepSeek-V3 在主观评测中的表现。通过引入额外的constitutional inputs，DeepSeek-V3 可以不断优化其符合宪法约束的方向。我们认为，这种结合补充信息和 LLM 作为反馈源的范式至关重要。LLM 不仅可以作为通用的处理器，还可以将不同场景中的非结构化信息转换为奖励信号，从而推动 LLM 自我优化。除了自我奖励（self-rewarding），我们还致力于探索其他通用且可扩展的奖励机制，以持续提升模型在广泛任务场景中的能力。

#### Multi-Token Prediction Evaluation

不同于逐个预测下一个 token 的传统方法，DeepSeek-V3 采用 MTP技术，可以预测下 2 个 token。结合投机解码（speculative decoding） 框架（Leviathan et al., 2023; Xia et al., 2023），该方法显著加快了模型的解码速度。

一个自然的问题是：额外预测的第二个 token 被接受的概率是多少？
根据我们的评测结果，第二个 token 预测的接受率在不同主题的生成任务中稳定在 85% 至 90%，表现出高度的可靠性。这一高接受率使得 DeepSeek-V3 解码速度提升至 1.8 倍的 TPS（Tokens Per Second）。

---

# DeepSeek-R1-Zero（Deepseekmath）





---

# DeepSeek-R1

## 摘要  

我们介绍了第一代推理模型 DeepSeek-R1-Zero 和 DeepSeek-R1。DeepSeek-R1-Zero 通过大规模强化学习（RL）训练，**不依赖监督微调（SFT）** 作为预处理步骤，并展现出了卓越的推理能力。在 RL 过程中，DeepSeek-R1-Zero 自然涌现出多种强大且有趣的推理行为。然而，它也面临一些挑战，例如可读性较差和语言混杂。为了解决这些问题并进一步增强推理能力，我们引入了 DeepSeek-R1，该模型在 RL 之前采用了多阶段训练和冷启动数据。DeepSeek-R1 在推理任务上达到了与 OpenAI-o1-1217 相当的性能。为了支持研究社区，我们开源了 DeepSeek-R1-Zero、DeepSeek-R1 以及基于 Qwen 和 Llama 从 DeepSeek-R1 蒸馏得到的六个密集模型（1.5B、7B、8B、14B、32B、70B）。  

## 1. 引言  

近年来，大型语言模型（LLMs）经历了快速的迭代与发展（Anthropic, 2024; Google, 2024; OpenAI, 2024a），逐步缩小了与通用人工智能（AGI）之间的差距。  

近期，后训练（post-training）已成为完整训练流程中的重要组成部分。研究表明，后训练能够提高推理任务的准确性，使模型更符合社会价值观，并适应用户偏好，同时相较于预训练消耗更少的计算资源。在推理能力方面，OpenAI 的 o1 系列模型（OpenAI, 2024b）首次通过扩展思维链（Chain-of-Thought）推理过程的长度，在推理任务（如数学、编程、科学推理）上取得了显著提升。然而，如何在测试时有效扩展推理能力仍然是研究界的开放性问题。先前的研究探索了多种方法，包括基于过程的奖励模型（Lightman et al., 2023; Uesato et al., 2022; Wang et al., 2023）、强化学习（Kumar et al., 2024）、以及搜索算法（如蒙特卡洛树搜索和束搜索）（Feng et al., 2024; Trinh et al., 2024; Xin et al., 2024）。然而，目前尚无方法能在一般推理任务上达到 OpenAI o1 系列的水平。  

在本研究中，我们首次尝试使用纯强化学习（RL）来提升语言模型的推理能力。我们的目标是探索大型语言模型在无监督数据的情况下发展推理能力的潜力，并通过纯 RL 过程实现自我进化。具体而言，我们使用 DeepSeek-V3-Base 作为基础模型，并采用 GRPO（Shao et al., 2024）作为 RL 框架来提升模型在推理任务上的表现。在训练过程中，DeepSeek-R1-Zero 自然涌现出许多强大且有趣的推理行为。经过数千次 RL 训练步骤后，DeepSeek-R1-Zero 在推理基准测试上表现卓越。例如，在 AIME 2024 竞赛中，其 pass@1 得分从 15.6% 提升至 71.0%，并通过多数投票（majority voting）进一步提升至 86.7%，达到了与 OpenAI-o1-0912 相当的性能。  

然而，DeepSeek-R1-Zero 存在一些缺陷，如可读性较差和语言混杂。为了解决这些问题并进一步增强推理能力，我们引入了 DeepSeek-R1。该模型采用少量冷启动数据和多阶段训练流程，具体包括：  
1. 收集数千条冷启动数据以对 DeepSeek-V3-Base 进行微调；  
2. 进行类似 DeepSeek-R1-Zero 的推理导向 RL 训练；  
3. 在 RL 过程接近收敛时，通过拒绝采样（rejection sampling）从 RL 训练的检查点生成新的 SFT 数据，并结合来自 DeepSeek-V3 的监督数据（包括写作、事实性问答和自我认知等领域），重新训练 DeepSeek-V3-Base；  
4. 在微调完成后，模型进一步经历一次 RL 训练，考虑所有场景的提示（prompts）。  

经过上述步骤，我们得到了 DeepSeek-R1 检查点，其性能达到了 OpenAI-o1-1217 的水平。  

此外，我们探索了从 DeepSeek-R1 到较小规模密集模型的蒸馏。以 Qwen2.5-32B（Qwen, 2024b）作为基础模型，直接从 DeepSeek-R1 进行蒸馏的效果优于在 Qwen2.5-32B 上应用 RL。这表明，大规模模型学习到的推理模式对于提升推理能力至关重要。我们开源了基于 Qwen 和 Llama（Dubey et al., 2024）系列的蒸馏模型。其中，我们的 14B 蒸馏模型远超最先进的开源模型 QwQ-32B-Preview（Qwen, 2024a），而蒸馏后的 32B 和 70B 模型在推理基准测试中创造了密集模型的新纪录。





# 参考文献


